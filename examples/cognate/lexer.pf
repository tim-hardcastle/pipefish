import

"strings"
"unicode"

newtype 

TokenType = enum BOOLEAN, DEF, IDENT, INTEGER, LET, LPAREN, RPAREN, SEMICOLON, STRING
Acceptable = abstract int/string/bool/null
MetaData = struct(lit string, line, ch int)
Token = struct(tokenType TokenType, val Acceptable, md MetaData)

const

WHITESPACE = [' ', '\t']
PUNCTUATION = ['(', ')', ';']
DOUBLEQUOTE = ['"']
PUNCTUATION_MAP = map("("::LPAREN,
                   .. ")"::RPAREN,
                   .. ";"::SEMICOLON)

def 

// We won't usually want to see all the fields, so we overload the native string function.
string(t Token) -> string : 
    t[val] in null :
        string t[tokenType]
    else :
        (string t[tokenType]) + "(" + (string t[val]) + ")"
        
lex(code string) -> list :
    from tokens = [] for i::s = range lines :
        tokens + slurpLine s, i + 1
given :
    lines = code -> strings.split(that, "\n") >> strings.trim(that, " ")

slurpLine(code string, lineINTEGER int) -> list : 
    first from tokens, pos = [], 0 for :
        pos >= len code :
            break
        word[0] == '"' : \\
            tokens + [makeToken(word + '"', lineINTEGER, firstChar)], nextChar
        unicode.isLower word[0] : // Cognate treats such words as comments.
            tokens, nextChar
        else :
            tokens + [makeToken(word, lineINTEGER, firstChar)], nextChar
    given :
        unprocessedCode = code[pos::len code] 
        firstChar = pos + skipWhitespace unprocessedCode 
        word = slurpNext code[firstChar::len code] 
        nextChar = firstChar + len word
        
slurpNext(code string) -> string : 
    code[0] == '"' : 
        '"' + slurpTo(code[1::len(code)], DOUBLEQUOTE) + '"'
    code[0] in PUNCTUATION :
        string(code[0])
    else :
        slurpTo(code, WHITESPACE + PUNCTUATION)

skipWhitespace(code string) -> int :
    from count = 0 for i = 0; i < len(code) and code[i] in WHITESPACE; i + 1 :
        count + 1 

slurpTo (code string, terminators list) : 
    from result = "" for i = 0; not (i == len code or code[i] in terminators); i + 1 :
        result + code[i] 

makeToken(word string, lineINTEGER, firstChar int) : 
    word[0] in PUNCTUATION :
        Token(PUNCTUATION_MAP[word], NULL, metadata)
    word[0] == '"' :
        Token(STRING, word[1::len(word)-2], metadata)
    valid int word : 
        Token(INTEGER, int(word), metadata)
    word in ["True", "False"] :
        Token(BOOLEAN, (word == "True"), metadata)
    word in ["Def"] :
        Token(DEF, word, metadata)
    word in ["Let"] :
        Token(LET, word, metadata)
    else :
        Token(IDENT, word, metadata)
given :
    metadata = MetaData(word, lineINTEGER, firstChar)

