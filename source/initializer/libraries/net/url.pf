import 

golang "net/url"
golang "errors"


newtype

UserInfo = struct(username, password string)

// TODO --- it is currently a syntax error to use , newline .. in cases like these.
Url = struct(scheme, opaque string, user UserInfo, host, path, rawPath string, omitHost, forceQuery bool, rawQuery, fragment, rawFragment string) 

def

// joinPath(base string, elem ... string) -> string/error : golang {
//     r, e := url.JoinPath(base, elem ...)
//     if e != nil {
//         return e 
//     }
//     return r 
// }

pathEscape(s string) -> string : golang {
    return url.PathEscape(s)
}

pathUnescape(s string) -> string/error  : golang {
    r, e := url.PathUnescape(s)
    if e != nil {
        return e 
    }
    return r 
}

queryEscape(s string) -> string : golang {
    return url.QueryEscape(s)
}

queryUnescape(s string) -> string/error : golang {
    r, e := url.QueryUnescape(s)
    if e != nil {
        return e 
    }
    return r 
}

parse(rawUrl string) -> Url/error : golang {
    u, err := url.Parse(rawUrl)
    if err != nil {
        return err 
    } else {
        return urlUrlToUrl(u)
    }
}

parseInContext(v Url, rawUrl string) -> Url/error : golang {
    u, err := urlToUrlUrl(v).Parse(rawUrl)
    if err != nil {
        return err 
    } else {
        return urlUrlToUrl(u)
    }
}

parseRequestUri(rawUrl string) -> Url/error : golang {
    u, err := url.ParseRequestURI(rawUrl)
    if err != nil {
        return err 
    } else {
        return urlUrlToUrl(u)
    }
}

escapedFragment(u Url) -> string : golang {
    return urlToUrlUrl(u).EscapedFragment()
}

escapedPath(u Url) -> string : golang {
    return urlToUrlUrl(u).EscapedPath()
}

hostname(u Url) -> string : golang {
    return urlToUrlUrl(u).Hostname()
}

isAbs(u Url) -> bool : golang {
    return urlToUrlUrl(u).IsAbs()
}

joinPath(u Url, elem ... string): golang {
    return urlToUrlUrl(u).JoinPath(elem ...)
}

port(u Url) -> string : golang {
    return urlToUrlUrl(u).Port()
}

query(u Url) : golang {
    return urlToUrlUrl(u).Query()
}

redacted(u Url) -> string : golang {
    return urlToUrlUrl(u).Redacted()
}

requestUri(u Url) -> string : golang {
    return urlToUrlUrl(u).RequestURI()
}

resolveReference(u, v Url) -> Url : golang {
    return urlUrlToUrl(urlToUrlUrl(u).ResolveReference(urlToUrlUrl(v)))
}

string(u Url) -> string : golang {
    return urlToUrlUrl(u).String()
}

parseQuery(query string) -> map/error : golang {
    r, err := url.ParseQuery(query)
    if err != nil {
        return err 
    } else {
        return r
    }
}

encode(values map) -> string/error : golang {
    goMap := url.Values{}
    for key, list := range values {
        if goKey, ok := key.(string); !ok {
            return errors.New("key in map is not of type `string`")
        } else {
            if rawList, ok := list.([]any); ok {
                return errors.New("value in map is not of type `list`")
            } else {
            goList := []string{}
            for _, el := range rawList {
                if goEl, ok := el.(string); !ok {
                    return errors.New("element in list in map is not of type `string`")
                } else {
                    goList = append(goList, goEl)
                }
            }
            goMap[goKey] = goList
            }
        }
    }
    return goMap.Encode()
}

golang {
    func urlUrlToUrl(u *url.URL) Url {
        password, _ := u.User.Password()
        return Url{
            Scheme: u.Scheme,
            Opaque: u.Opaque, 
            User: UserInfo{Username: u.User.Username(),
                           Password: password,
            },
            Host: u.Host,
            Path: u.Path,
            RawPath: u.RawPath,
            OmitHost: u.OmitHost,
            ForceQuery: u.ForceQuery,
            RawQuery: u.RawQuery,
            Fragment: u.Fragment,
            RawFragment: u.RawFragment,
        }
    }

    func urlToUrlUrl(u Url) *url.URL {
        return &url.URL{
            Scheme: u.Scheme,
            Opaque: u.Opaque, 
            User: url.UserPassword(u.User.Username, u.User.Password),
            Host: u.Host,
            Path: u.Path,
            RawPath: u.RawPath,
            OmitHost: u.OmitHost,
            ForceQuery: u.ForceQuery,
            RawQuery: u.RawQuery,
            Fragment: u.Fragment,
            RawFragment: u.RawFragment,
        }
    }
}

