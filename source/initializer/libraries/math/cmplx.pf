import

golang "math/cmplx"
golang "strconv"

newtype 

Complex = wrapper complex128 

def

Complex(a, b float) -> Complex : golang {
    return complex(a, b)
}

string(z Complex) -> string : golang {
    return strconv.FormatComplex(z.(complex128), 'g', 6, 128)
}

(x Complex) + (y Complex) -> Complex :
    goAdd x, y 

(x Complex) - (y Complex) -> Complex :
    goSub x, y 

(x Complex) * (y Complex) -> Complex :
    goMul x, y 

(x Complex) / (y Complex) -> Complex :
    goDiv x, y 

(x Complex) ^ (y Complex) -> Complex :
    goPow x, y 

(x Complex) ^ (y float) -> Complex :
    goPow x, Complex(y, 0.0) 

// (x float) + (y Complex) -> Complex :
//     goAdd C(x, 0.0), y 

// (x float) - (y Complex) -> Complex :
//     goSub C(x, 0.0), y 

// (x float) * (y Complex) -> Complex :
//     goMul C(x, 0.0), y 

// (x float) / (y Complex) -> Complex :
//     goDiv C(x, 0.0), y 

// (x Complex) + (y float) -> Complex :
//     goAdd x, C(y, 0.0)

// (x Complex) - (y float) -> Complex :
//     goSub x, C(y, 0.0)

// (x Complex) * (y float) -> Complex :
//     goMul x, C(y, 0.0)

// (x Complex) / (y float) -> Complex :
//     goDiv x, C(y, 0.0)

abs(x Complex) -> float : golang {
    return cmplx.Abs(x.(complex128)) 
}

acos(x Complex) -> Complex : golang {
    return cmplx.Acos(x.(complex128)) 
}

acosh(x Complex) -> Complex : golang {
    return cmplx.Acosh(x.(complex128)) 
}

asin(x Complex) -> Complex : golang {
    return cmplx.Asin(x.(complex128)) 
}

asinh(x Complex) -> Complex : golang {
    return cmplx.Asinh(x.(complex128)) 
}

atan(x Complex) -> Complex : golang {
    return cmplx.Atan(x.(complex128)) 
}

atanh(x Complex) -> Complex : golang {
    return cmplx.Atanh(x.(complex128)) 
}

conj(x Complex) -> Complex : golang {
    return cmplx.Conj(x.(complex128)) 
}

cos(x Complex) -> Complex : golang {
    return cmplx.Cos(x.(complex128)) 
}

cosh(x Complex) -> Complex : golang {
    return cmplx.Cosh(x.(complex128)) 
}

cot(x Complex) -> Complex : golang {
    return cmplx.Cot(x.(complex128)) 
}

exp(x Complex) -> Complex : golang {
    return cmplx.Exp(x.(complex128)) 
}

imag(x Complex) -> float : golang {
    return imag(x.(complex128)) 
}

inf() -> Complex : golang {
    return cmplx.Inf() 
}

isInf(x Complex) -> bool : golang {
    return cmplx.IsInf(x.(complex128))
}

isNaN(x Complex) -> bool : golang {
    return cmplx.IsNaN(x.(complex128))
}

log(x Complex) -> Complex : golang {
    return cmplx.Log(x.(complex128)) 
}

log_10(x Complex) -> Complex : golang {
    return cmplx.Log10(x.(complex128)) 
}

naN() -> Complex : golang {
    return cmplx.NaN() 
}

phase(x Complex) -> float : golang {
    return cmplx.Phase(x.(complex128)) 
}

polar(x Complex) -> float, float : golang {
    return cmplx.Polar(x.(complex128)) 
}

real(x Complex) -> float : golang {
    return real(x.(complex128)) 
}

rect(r, θ float) -> Complex : golang {
    return cmplx.Rect(r, θ) 
}

sin(x Complex) -> Complex : golang {
    return cmplx.Sin(x.(complex128)) 
}

sinh(x Complex) -> Complex : golang {
    return cmplx.Sinh(x.(complex128)) 
}

sqrt(x Complex) -> Complex : golang {
    return cmplx.Sqrt(x.(complex128)) 
}

tan(x Complex) -> Complex : golang {
    return cmplx.Tan(x.(complex128)) 
}

tanh(x Complex) -> Complex : golang {
    return cmplx.Tanh(x.(complex128)) 
}

private 

goAdd(x Complex, y Complex) -> Complex : golang {
    return x.(complex128) + y.(complex128)
}

goSub(x Complex, y Complex) -> Complex : golang {
    return x.(complex128) - y.(complex128)
}

goMul(x Complex, y Complex) -> Complex : golang {
    return x.(complex128) * y.(complex128)
}

goDiv(x Complex, y Complex) -> Complex : golang {
    return x.(complex128) / y.(complex128)
}

goPow(x, y Complex) -> Complex : golang {
    return cmplx.Pow(x.(complex128), y.(complex128)) 
}

golang { 
    func Equals(x, y any) bool {
        switch x := x.(type) {
        case complex128:
            return x == y.(complex128)
        default:
            return false
        }
    }

    func Literal(x any) string {
        switch x := x.(type) {
        case complex128:
            return "Complex(" + strconv.FormatFloat(real(x), 'g', -1, 64) + ", " +
                strconv.FormatFloat(imag(x), 'g', -1, 64) + ")"
        default:
            return "can't serialize value"
        } 
    }
}

