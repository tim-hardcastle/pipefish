package compiler

import (
	"embed"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"testing"

	"github.com/tim-hardcastle/pipefish/source/dtypes"
	"github.com/tim-hardcastle/pipefish/source/err"
	"github.com/tim-hardcastle/pipefish/source/parser"
	"github.com/tim-hardcastle/pipefish/source/settings"
	"github.com/tim-hardcastle/pipefish/source/text"
	"github.com/tim-hardcastle/pipefish/source/token"
	"github.com/tim-hardcastle/pipefish/source/values"
	"github.com/tim-hardcastle/pipefish/source/vm"
)

//go:embed test-files/*
var TestFolder embed.FS

type Compiler struct {
	// Permanent state, i.e. it is unchanged after initialization.
	Number                   uint32                             // The number of the compiler in order of compilation.
	Vm                       *vm.Vm                             // The vm we're compiling to.
	P                        *parser.Parser                     // The parser the compiler's using to parse with..
	GlobalConsts             *Environment                       // The global constants of the module.
	GlobalVars               *Environment                       // The global variables of the module.
	Fns                      []*CpFunc                          // The functions the compiler knows about, in a format it can use.
	TypeNameToTypeScheme     map[string]AlternateType           // A map from the names of built-in or declared concrete or abstract types to an AlternateType typescheme representing them.
	Modules                  map[string]*Compiler               // Both internal services, and stubs that call the externals.
	CallHandlerNumbersByName map[string]uint32                  // Map from the names of external services to their index as stored in the vm.
	Timestamp                int64                              // The timestamp from the source file. TODO --- "the" source file? Wat about NULL-imports?
	ScriptFilepath           string                             // Where the script for the module is (where "the" script is the one that supplies the namespace, not the NULL-imports).
	TypeToCloneGroup         map[values.ValueType]AlternateType // A map from any clonable or clone type to an alt type containing the parent type and its clones.
	labelResolvingCompilers  []*Compiler                        // We use this to resolve the meaning of labels and enums.
	TupleType                uint32                             // Location of a constant saying {TYPE, <type number of tuples>}, so that 'type (x tuple)' in the builtins has something to return. Query, why not just define 'type (x tuple) : tuple' ?
	Common                   *CommonCompilerBindle              // Struct to hold info shared by the compilers.
	GeneratedAbstractTypes   dtypes.Set[string]                 // Types such as clone{int} which are automatically generated, and so shouldn't be part of the API serialization.
	FunctionForest           map[string]*FunctionTree           // Used for type dispatch
	DocString                string                             // Doctring for the module.
	API                      string                             // If the compiler is the root of the service, this will contain the serialized API of the service.
	ApiDescription           [][]ApiItem                        // Data used to generate a description of the API.
	TypeMap                  TypeSys                            // Abstract types indexed by name.

	// Temporary state.
	ThunkList       []ThunkData   // Records what thunks we made so we know what to unthunk at the top of the function.
	RecursionStore  []BkRecursion // Places in the code where we need to go back and doctor it to make the recursion work for outer functions.
	RecurringFunctions map[uint32]dtypes.Set[uint32]  // Records dependencies of mutually recurring functions at initialization.
	memPushData     [][]bkMemPush // Stack of lists for backtracking on pushing memory to the stack for recursion.
	lambdaMemStarts []uint32      // A stack for the start (in memory, not code) of the lambda we're compiling so that if it turns out to be recursive we know the low bound of where to start saving memory from.
	forData         [][]any       // A stack (one list for each nested 'for' loop) of lists of gotos etc generated by 'break' and 'continue'.
	showCompile     bool          // Whether we show the internals of the compiler at compile time.
}

// Initializes a compiler.
func NewCompiler(p *parser.Parser, ccb *CommonCompilerBindle) *Compiler {
	newC := &Compiler{
		Number:                   ccb.CompilerCount,
		P:                        p,
		GlobalConsts:             NewEnvironment(),
		GlobalVars:               NewEnvironment(),
		ThunkList:                []ThunkData{},
		Fns:                      []*CpFunc{},
		Modules:                  make(map[string]*Compiler),
		CallHandlerNumbersByName: make(map[string]uint32),
		TypeToCloneGroup:         make(map[values.ValueType]AlternateType),
		TypeNameToTypeScheme:     INITIAL_TYPE_SCHEMES,
		Common:                   ccb,
		GeneratedAbstractTypes:   make(dtypes.Set[string]),
		FunctionForest:           make(map[string]*FunctionTree),
		TypeMap:                  TypeSys{},
	}
	for name := range ClonableTypes {
		newC.GeneratedAbstractTypes.Add("clones{" + name + "}")
	}
	newC.pushRCompiler(newC)
	ccb.CompilerCount++
	return newC
}

type CommonCompilerBindle struct {
	SharedTypenameToTypeList map[string]AlternateType
	AnyTypeScheme            AlternateType
	AnyTuple                 AlternateType
	IsRangeable              AlternateType
	CodeGeneratingTypes      dtypes.Set[values.ValueType]
	LabelIsPrivate           []bool
	Types                    TypeSys
	CompilerCount            uint32
}

func NewCommonCompilerBindle() *CommonCompilerBindle {
	newBindle := &CommonCompilerBindle{
		SharedTypenameToTypeList: map[string]AlternateType{
			// TODO --- why can't we define one in terms of the other?
			"any": AltType(values.INT, values.BOOL, values.STRING, values.RUNE, values.TYPE, values.FUNC, values.PAIR, values.LIST, values.MAP, values.SET, values.LABEL, values.SNIPPET),
		},
		AnyTypeScheme:       AlternateType{},
		AnyTuple:            AlternateType{},
		CodeGeneratingTypes: (make(dtypes.Set[values.ValueType])).Add(values.FUNC),
		Types:               NewCommonTypeMap(),
	}
	for _, name := range AbstractTypesOtherThanAny {
		newBindle.SharedTypenameToTypeList[name] = AltType()
	}
	for name, ty := range ClonableTypes {
		newBindle.SharedTypenameToTypeList["clones{"+name+"}"] = AltType(ty)
	}
	anyOrNull := newBindle.SharedTypenameToTypeList["any"].Union(altType(values.NULL))
	newBindle.AnyTuple = AlternateType{TypedTupleType{anyOrNull}}
	newBindle.AnyTypeScheme = make(AlternateType, len(newBindle.SharedTypenameToTypeList["any"]), 2+len(newBindle.SharedTypenameToTypeList["any"]))
	copy(newBindle.AnyTypeScheme, anyOrNull)
	newBindle.AnyTypeScheme = newBindle.AnyTypeScheme.Union(newBindle.AnyTuple)
	newBindle.SharedTypenameToTypeList["tuple"] = newBindle.AnyTuple
	newBindle.IsRangeable = altType(values.TUPLE, values.STRING, values.TYPE, values.PAIR, values.LIST, values.MAP, values.SET, values.SNIPPET)
	return newBindle
}

func (ccb *CommonCompilerBindle) AddTypeNumberToSharedAlternateTypes(typeNo values.ValueType, abTypes ...string) {
	abTypes = append(abTypes, "any")
	for _, ty := range abTypes {
		ccb.SharedTypenameToTypeList[ty] = ccb.SharedTypenameToTypeList[ty].Union(altType(typeNo))
	}
	ccb.AnyTuple = AlternateType{TypedTupleType{ccb.SharedTypenameToTypeList["any"].Union(altType(values.NULL))}}
	ccb.AnyTypeScheme = ccb.AnyTypeScheme.Union(altType(typeNo))
	ccb.AnyTypeScheme[len(ccb.AnyTypeScheme)-1] = ccb.AnyTuple
	ccb.SharedTypenameToTypeList["tuple"] = ccb.AnyTuple
}

// The `Context` is passed around the compiler to keep track of what it's trying to do. Is it compiling a function
// body? Is it meant to be logging anything? Is it compiling a function, a command, an expression from the REPL? Etc.
type Context struct {
	Env            *Environment    // The association of variable names to variable locations.
	FName          string          // If we're compiling a function, the name of the function we're compiling.
	Access         CpAccess        // Whether we are compiling the body of a command; of a function; something typed into the REPL, etc.
	IsReturn       bool            // Is the value of the node to be evaluated potentially a return value of the function being compiled?
	Typecheck      FiniteTupleType // The type(s) for the compiler to check for if isReturn is true; nil if no return types are defined.
	LowMem         uint32          // Where the memory of the function we're compiling (if indeed we are) starts, and so the lowest point from which we may need to copy memory in case of recursion.
	TrackingFlavor LogFlavor       // Whether we should be tracking something and if so what.
	LogFlavor      LogFlavor       // Whether we should be logging something and if so what.
	ForReturns     AlternateType   // What (besides an error) we may expect 'for' to return, and therefor the expected result of a 'continue' or a 'break' with out a value after it.
}

// Unless we're going down a branch, we want the new context for each node compilation to have no forward type-checking.
// This function concisely removes it.
func (ctxt Context) x() Context {
	ctxt.IsReturn = false
	return ctxt
}

type cpResult struct {
	Types    AlternateType
	Foldable bool
	Failed   bool
}

var FAIL = cpResult{Failed: true}

func concResult(ty values.ValueType, foldable bool) cpResult {
	return cpResult{Types: AltType(ty), Foldable: foldable}
}

// This is the type of the access that the compiler has at any given point in the compilation. Are we compiling code in a function,
// a command, an expression from the REPL?
type CpAccess int

const ( // We use this to keep track of what we're doing so we don't e.g. call a command from a function, or let a command see the globals without a `global` keyword, etc.
	REPL   CpAccess = iota // Call from the REPL, or an external service. TODO --- distinguish them for clarity?
	CMD                    // We're in a command.
	DEF                    // We're in a function.
	INIT                   // We're initializing the global variables.
	LAMBDA                 // We're in a lambda function.
)

// The `Do` function of the VM is what a Service calls to get it to evaluate a line of code from the REPL.
// It parses the line to an AST, initializes the context, calls `CompileNode` with the AST and the context
// as arguments, runs the resulting code, rolls back the VM, and returns the value it got.
func (cp *Compiler) Do(line string) values.Value {
	state := cp.GetState()
	cT := cp.CodeTop()
	node := cp.P.ParseLine("REPL input", line)
	if settings.SHOW_PARSER {
		fmt.Println("Parsed line:", node.String())
	}
	if cp.P.ErrorsExist() {
		return val(values.ERROR, &err.Error{})
	}
	ctxt := Context{Env: cp.GlobalVars, Access: REPL, LowMem: DUMMY, TrackingFlavor: LF_NONE}
	cp.CompileNode(node, ctxt)
	if cp.P.ErrorsExist() {
		return val(values.ERROR, &err.Error{})
	}
	cp.Emit(vm.Ret)
	cp.Cm("Calling Run from Do.", node.GetToken())
	cp.Vm.Run(cT)
	result := cp.Vm.Mem[cp.That()]
	cp.Rollback(state, node.GetToken())
	return result
}

// The heart of the compiler. It starts by taking a snapshot of the vm. It then does a big switch on the node type
// and compiles accordingly. It then performs some sanity checks and, if the compiled expression is constant,
// evaluates it and uses the snapshot to roll back the vm.
//
// The node types in the switch are in alphabetical order.
func (cp *Compiler) CompileNode(node parser.Node, ctxt Context) cpResult {
	cp.Cm("Compiling node of type "+(reflect.TypeOf(node).String())[5:]+" with literal "+text.Emph(node.GetToken().Literal)+".", node.GetToken())
	cp.showCompile = settings.SHOW_COMPILER && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(node.GetToken().Source))
	result := cpResult{}
	state := cp.GetState()
	cT := cp.CodeTop()
	env := ctxt.Env
	ac := ctxt.Access
NodeTypeSwitch:
	switch node := node.(type) {
	// Note that assignments in `given` blocks and var and const initialization are taken care of by the initializer, so we only have to deal with the cases where
	// the assignment is in the body of a function or in the REPL.
	case *parser.AssignmentExpression:
		sig, ok := cp.P.ReparseSig(node.Left, parser.INFERRED_TYPE_AST)
		if !ok {
			return FAIL
		}
		cp.Cm("Assignment signature is "+text.Emph(sig.String()), &node.Token)
		rhsIsError := BkEarlyReturn(DUMMY) // TODO --- since assigning an error would violate a type check, which we also perform, is this necessary?
		cpR := cp.CompileNode(node.Right, ctxt.x())
		if cpR.Failed {
			return FAIL
		}
		rhsResult := cp.That()
		if cpR.Types.Contains(values.ERROR) {
			rhsIsError = cp.VmConditionalEarlyReturn(vm.Qtyp, rhsResult, uint32(values.ERROR), rhsResult)
			result.Types = AltType(values.SUCCESSFUL_VALUE, values.ERROR)
		} else {
			result.Types = AltType(values.SUCCESSFUL_VALUE)
		}
		types := cpR.Types.without(SimpleType(values.ERROR))
		newSig := alternateSig{} // A more flexible form of signature that allows the types to be represented as a string or as an AlternateType.
		// We need to do typechecking differently according to whether anything on the LHS is a global, in which case we need to early-return an error from the typechecking.
		flavor := CHECK_LOCAL_CMD_ASSIGNMENTS
		for i, pair := range sig {
			v, ok := env.GetVar(pair.VarName)
			if ok {
				cp.Cm("Inferring the type of a variable "+text.Emph(pair.VarName)+" already defined ", &node.Token)
				if sig[i].VarType != parser.INFERRED_TYPE_AST { // Then as we can't change the type of an existing variable, we must check that we're defining it the same way.
					if !Equals(v.Types, cp.GetAlternateTypeFromTypeAst(sig[i].VarType)) {
						cp.Throw("comp/assign/type/b", node.GetToken(), pair.VarName)
						return FAIL
					}
				}
				if v.Access != REFERENCE_VARIABLE { // TODO --- There's probably a more elgant way of dealing with the reference variable thing if I think about it, but as I intend to type them anyway and this will get refactored away it's not a big deal.
					newSig = append(newSig, NameAlternateTypePair{pair.VarName, v.Types})
				} else {
					newSig = append(newSig, NameAlternateTypePair{pair.VarName, cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST)})
				}
				if v.Access == GLOBAL_CONSTANT_PRIVATE || v.Access == LOCAL_VARIABLE_THUNK || v.Access == LOCAL_CONSTANT || v.Access == LOCAL_FUNCTION_CONSTANT ||
					v.Access == VERY_LOCAL_CONSTANT || v.Access == VERY_LOCAL_VARIABLE || v.Access == FUNCTION_ARGUMENT || v.Access == LOCAL_FUNCTION_THUNK ||
					v.Access == TYPE_ARGUMENT {
					cp.Throw("comp/assign/immutable", node.Left.GetToken(), pair.VarName)
					return FAIL
				}
				if ac == REPL && (ALL_PRIVATE_ACCESS.Contains(v.Access)) {
					cp.Throw("comp/assign/private", node.Left.GetToken(), pair.VarName)
					return FAIL
				}
				if ac == REPL && (ALL_CONSTANT_ACCESS.Contains(v.Access)) {
					cp.Throw("comp/assign/const", node.Left.GetToken(), pair.VarName)
					return FAIL
				}
				if v.Access == GLOBAL_VARIABLE_PUBLIC {
					flavor = CHECK_GLOBAL_ASSIGNMENTS
				}
			} else { // The variable doesn't already exist.
				cp.Cm("Assignment creating local variable "+text.Emph(sig.String())+".", &node.Token)
				if ac == REPL {
					cp.Throw("comp/assign/repl", node.Left.GetToken(), pair.VarName)
					return FAIL
				}
				cp.Reserve(values.UNDEFINED_TYPE, DUMMY, node.GetToken())
				if vType, ok := pair.VarType.(*parser.TypeWithName); ok && vType.OperatorName == "tuple" {
					cp.Cm("Adding variable in ASSIGN, 1", node.GetToken())
					cp.AddThatAsVariable(env, pair.VarName, LOCAL_VARIABLE, cp.Common.AnyTuple, node.GetToken())
					newSig = append(newSig, NameAlternateTypePair{pair.VarName, cp.Common.AnyTuple})
				} else {
					typesAtIndex := typesAtIndex(types, i)
					cp.Cm("Adding variable in ASSIGN, 2", node.GetToken())
					cp.AddThatAsVariable(env, pair.VarName, LOCAL_VARIABLE, typesAtIndex, node.GetToken())
					if sig[i].VarType == parser.INFERRED_TYPE_AST {
						newSig = append(newSig, NameAlternateTypePair{pair.VarName, typesAtIndex})
					} else {
						newSig = append(newSig, NameAlternateTypePair{pair.VarName, cp.GetAlternateTypeFromTypeAst(sig[i].VarType)})
					}
				}
			}
		}
		cp.Cm("Typechecking and inserting result into variables.", node.GetToken())
		typeCheckFailed := cp.EmitTypeChecks(rhsResult, types, env, newSig, node.GetToken(), flavor)
		cp.Put(vm.Asgm, values.C_OK)
		cp.VmComeFrom(rhsIsError, typeCheckFailed)
		break NodeTypeSwitch
	case *parser.BooleanLiteral:
		cp.Reserve(values.BOOL, node.Value, node.GetToken())
		result = concResult(values.BOOL, true)
		break
	case *parser.ComparisonExpression:
		if node.Operator == "==" {
			result = cp.compileEquals(node, ctxt.x())
			if result.Failed {
				return FAIL
			}
			break
		}
		if node.Operator == "!=" {
			result = cp.compileEquals(node, ctxt.x())
			if result.Failed {
				return FAIL
			}
			cp.Put(vm.Notb, cp.That())
			break
		}
	case *parser.FloatLiteral:
		cp.Reserve(values.FLOAT, node.Value, node.GetToken())
		result = concResult(values.FLOAT, true)
	case *parser.ForExpression:
		result = cp.compileForExpression(node, ctxt)
	case *parser.FuncExpression:
		ok := cp.compileLambda(env, ctxt, node, node.GetToken())
		if !ok {
			return FAIL
		}
		result = concResult(values.FUNC, false) // Things that return functions and snippets are not folded, even if they are constant.
	case *parser.Identifier:
		switch node.Value {
		case "continue":
			result = cp.emitContinue(&node.Token, ctxt)
			break NodeTypeSwitch
		case "break":
			result = cp.emitBreakWithoutValue(&node.Token, ctxt)
			break NodeTypeSwitch
		case "NULL":
			cp.Reserve(values.NULL, nil, &node.Token)
			result = concResult(values.NULL, true)
			break NodeTypeSwitch
		case "OK":
			cp.Reserve(values.SUCCESSFUL_VALUE, nil, &node.Token)
			result = concResult(values.SUCCESSFUL_VALUE, true)
			break NodeTypeSwitch
		}
		var argumentCompiler *Compiler
		if node.Token.Namespace == "" {
			argumentCompiler = cp.topRCompiler()
		} else {
			argumentCompiler = cp.getResolvingCompiler(node.GetToken(), ac)
		}
		// If we're parsing the parameters of a namespaced function, then we are allowed a
		// window through to its public global constants, which will be in the enumCompiler.
		// If we tack it on as the Ext of the resolving compiler's global variables, then
		// since that would usually be the backstop of all the environments, it will normally
		// be nil and we won't break anything. These constants will therefore be shadowed by
		// anything more local, preventing surprising behaviors.
		if argumentCompiler != cp {
			cp.GlobalConsts.Ext = argumentCompiler.GlobalConsts
		}
		// Here we get the compiler suitable to the namespace of the identifier.
		resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
		var v *Variable
		var ok bool
		if resolvingCompiler != cp {
			v, ok = resolvingCompiler.GlobalConsts.GetVar(node.Value)
		} else {
			v, ok = env.GetVar(node.Value)
		}
		if !ok {
			cp.Throw("comp/ident/known", node.GetToken(), node.Value)
			cp.GlobalConsts.Ext = nil
			return FAIL
		}
		if (v.Access == GLOBAL_CONSTANT_PRIVATE || v.Access == GLOBAL_VARIABLE_PRIVATE) && ac == REPL {
			cp.Throw("comp/ident/private", node.GetToken())
			cp.GlobalConsts.Ext = nil
			return FAIL
		}
		if v.Access == LOCAL_VARIABLE_THUNK || v.Access == LOCAL_FUNCTION_THUNK {
			cp.Emit(vm.Untk, v.MLoc)
		}
		if v.Access == REFERENCE_VARIABLE {
			cp.Put(vm.Dref, v.MLoc)
			result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST)
		} else {
			cp.Put(vm.Asgm, v.MLoc)
			result.Types = v.Types
		}
		result.Foldable = ALL_CONSTANT_ACCESS.Contains(v.Access)
		cp.GlobalConsts.Ext = nil
	case *parser.IndexExpression:
		containerCpResult := cp.CompileNode(node.Left, ctxt.x())
		if containerCpResult.Failed {
			return FAIL
		}
		container := cp.That()
		newContext := ctxt.x()
		indexCpResult := cp.CompileNode(node.Index, newContext)
		if indexCpResult.Failed {
			return FAIL
		}
		index := cp.That()
		result.Foldable = containerCpResult.Foldable && indexCpResult.Foldable
		errTok := cp.ReserveToken(node.GetToken())
		// Things we can index:
		// Lists, by integers; or a pair for a slice.
		// Tuples, ditto.
		// Strings, ditto.
		// Pairs, by integers.
		// Snippets, by integers.
		// Maps, by any value we can Compare with another value.
		// Structs, by a label, preferably an appropriate one.

		containerType := containerCpResult.Types
		indexType := indexCpResult.Types
		if len(containerType.intersect(cp.Common.SharedTypenameToTypeList["clones{list}"])) == len(containerType) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.Put(vm.IdxL, container, index, errTok)
				result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST_OR_ERROR)
				break
			}
			if indexType.isOnlyCloneOf(cp.Vm, values.PAIR) {
				cp.Put(vm.SliL, container, index, errTok)
				result.Types = containerType.Union(AltType(values.ERROR))
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT, values.PAIR) {
				cp.Throw("comp/index/list", node.GetToken())
				return FAIL
			}
			result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST_OR_ERROR)
		}
		if len(containerType.intersect(cp.Common.SharedTypenameToTypeList["clones{string}"])) == len(containerType) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.Put(vm.Idxs, container, index, errTok)
				result.Types = AltType(values.ERROR, values.RUNE)
				break
			}
			if indexType.isOnlyCloneOf(cp.Vm, values.PAIR) {
				cp.Put(vm.Slis, container, index, errTok)
				result.Types = AltType(values.ERROR, values.STRING)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT, values.PAIR) {
				cp.Throw("comp/index/string", node.GetToken())
				return FAIL
			}

		}
		// TODO --- you can narrow the return types down given the `containerType`.
		if containerType.containsOnlyTuples() {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.Put(vm.IdxT, container, index, errTok)
				result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST_OR_ERROR)
				break
			}
			if indexType.isOnlyCloneOf(cp.Vm, values.PAIR) {
				cp.Put(vm.SliT, container, index, errTok)
				result.Types = AltType(values.ERROR, values.TUPLE)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT, values.PAIR) {
				cp.Throw("comp/index/tuple", node.GetToken())
				return FAIL
			}
		}
		if containerType.isOnlyCloneOf(cp.Vm, values.PAIR) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.Put(vm.Idxp, container, index, errTok)
				result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST_OR_ERROR)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT) {
				cp.Throw("comp/index/pair", node.GetToken())
				return FAIL
			}
		}
		if containerType.isOnlyCloneOf(cp.Vm, values.SNIPPET) {
			if indexType.isOnlyCloneOf(cp.Vm, values.INT) {
				cp.Put(vm.IxSn, container, index, errTok)
				result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST)
				break
			}
			if indexType.cannotBeACloneOf(cp.Vm, values.INT) {
				cp.Throw("comp/index/snippet", node.GetToken())
				return FAIL
			}
		}
		structT, ok := cp.alternateTypeIsOnlyStruct(containerType)
		if ok {
			structInfo := cp.Vm.ConcreteTypeInfo[structT].(vm.StructType)
			if indexType.isOnly(values.LABEL) {
				if indexCpResult.Foldable { // Then we can find the field number of the struct at compile time and throw away the computed label.
					indexNumber := cp.Vm.Mem[index].V.(int)
					labelName := cp.Vm.Labels[indexNumber]
					fieldNumber := structInfo.Resolve(indexNumber)
					if fieldNumber == -1 {
						cp.Throw("comp/index/struct/a", node.GetToken(), labelName, cp.Vm.DescribeType(structT, vm.LITERAL, 0))
						return FAIL
					}
					cp.Put(vm.IxZn, container, uint32(fieldNumber))
					result.Types = AbstractTypeToAlternateType(cp.Vm.ConcreteTypeInfo[structT].(vm.StructType).AbstractStructFields[fieldNumber])
					break
				}
				cp.Put(vm.IxZl, container, index, errTok)
				result.Types = AltType()
				for _, t := range cp.Vm.ConcreteTypeInfo[structT].(vm.StructType).AbstractStructFields {
					result.Types = result.Types.Union(AbstractTypeToAlternateType(t))
				}
				result.Types = result.Types.Union(AltType(values.ERROR))
				break
			}
			if indexType.IsNoneOf(values.LABEL) {
				cp.Throw("comp/index/struct/b", node.GetToken())
				return FAIL
			}
		}
		if cp.alternateTypeIsOnlyAssortedStructs(containerType) {
			if indexType.isOnly(values.LABEL) {
				if indexCpResult.Foldable { // Then we can find the field number of the struct at compile time and throw away the computed label.
					labelIsPossible := false
					labelIsCertain := true
					result.Types = AltType()
					for _, structTypeAsSimpleType := range containerType {
						structT := values.ValueType(structTypeAsSimpleType.(SimpleType))
						structInfo := cp.Vm.ConcreteTypeInfo[structT].(vm.StructType)
						indexNumber := cp.Vm.Mem[index].V.(int)
						fieldNumber := structInfo.Resolve(indexNumber)
						if fieldNumber != -1 {
							labelIsPossible = true
							result.Types = result.Types.Union(AbstractTypeToAlternateType(cp.Vm.ConcreteTypeInfo[structT].(vm.StructType).AbstractStructFields[fieldNumber]))
						} else {
							labelIsCertain = false
						}
					}
					if !labelIsPossible {
						cp.Throw("comp/index/struct/c", node.GetToken())
						return FAIL
					}
					if !labelIsCertain {
						result.Types = result.Types.Union(AltType(values.ERROR))
					}
					cp.Put(vm.IxZl, container, index, errTok)
					break
				}
				cp.Put(vm.IxZl, container, index, errTok)
				break
			}
		}
		// If we can't infer anything else about the types we can emit a catchall indexing operation.
		cp.Put(vm.IxXx, container, index, errTok)
		if containerType.Contains(values.TUPLE) {
			result.Types = cp.Common.AnyTypeScheme
		} else {
			result.Types = cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST)
		}
	case *parser.InfixExpression:
		if node.Operator == "given" {
			cp.Throw("comp/expect/given", &node.Token)
			break
		}
		if node.Operator == "," {
			result = cp.compileComma(node, ctxt.x())
			if result.Failed {
				return FAIL
			}
			break NodeTypeSwitch
		}
		resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
		cp.pushRCompiler(resolvingCompiler)
		result = resolvingCompiler.createFunctionCall(cp, node, ctxt.x(), node.GetToken().Namespace != "")
		cp.popRCompiler()
		if result.Failed {
			return FAIL
		}
	case *parser.IntegerLiteral:
		cp.Reserve(values.INT, node.Value, node.GetToken())
		result = concResult(values.INT, true)
	case *parser.LazyInfixExpression:
		// Instead of treating `and` and `or` and `;` as ordinary infixes, we want them to
		// be lazy, to short-circuit. So we do the typechecking by hand at the same time.
		leftTypecheck := BkEarlyReturn(DUMMY)
		rightTypecheck := BkEarlyReturn(DUMMY)
		leftError := BkEarlyReturn(DUMMY)
		rightError := BkEarlyReturn(DUMMY)
		if node.Operator == "or" {
			lResult := cp.CompileNode(node.Left, ctxt.x())
			if lResult.Failed {
				return FAIL
			}
			if !lResult.Types.Contains(values.BOOL) {
				cp.Throw("comp/bool/or/left", node.GetToken(), lResult.Types.describe(cp.Vm))
				return FAIL
			}
			leftRg := cp.That()
			if !lResult.Types.isOnly(values.BOOL) {
				if lResult.Types.Contains(values.ERROR) {
					leftError = cp.VmConditionalEarlyReturn(vm.Qtyp, leftRg, uint32(values.ERROR), leftRg)
				}
				if !lResult.Types.areOnly(values.BOOL, values.ERROR) {
					cp.ReserveError("vm/bool/or/left", node.Left.GetToken())
					leftTypecheck = cp.VmConditionalEarlyReturn(vm.Qntp, leftRg, uint32(values.BOOL), cp.That())
				}
			}
			shortCircuit := cp.VmConditionalEarlyReturn(vm.Qtru, leftRg, leftRg)
			rResult := cp.CompileNode(node.Right, ctxt.x())
			if rResult.Failed {
				return FAIL
			}
			if !rResult.Types.Contains(values.BOOL) {
				cp.Throw("comp/bool/or/right", node.GetToken(), rResult.Types.describe(cp.Vm))
				return FAIL
			}
			rightRg := cp.That()
			if !rResult.Types.areOnly(values.BOOL, values.ERROR) {
				cp.ReserveError("vm/bool/or/right", node.Right.GetToken())
			}
			if !rResult.Types.isOnly(values.BOOL) {
				if rResult.Types.Contains(values.ERROR) {
					rightError = cp.VmConditionalEarlyReturn(vm.Qtyp, rightRg, uint32(values.ERROR), rightRg)
				}
				if !rResult.Types.areOnly(values.BOOL, values.ERROR) {
					cp.ReserveError("vm/bool/or/right", node.Right.GetToken())
					rightTypecheck = cp.VmConditionalEarlyReturn(vm.Qtyp, rightRg, uint32(values.BOOL), rightRg)
				}
			}
			cp.VmComeFrom(shortCircuit, leftTypecheck, leftError, rightTypecheck, rightError)
			if lResult.Types.isOnly(values.BOOL) && rResult.Types.isOnly(values.BOOL) {
				result.Types = AltType(values.BOOL)
			} else {
				result.Types = AltType(values.BOOL, values.ERROR)
			}
			result.Foldable = lResult.Foldable && rResult.Foldable
			break
		}
		if node.Operator == "and" {
			lResult := cp.CompileNode(node.Left, ctxt.x())
			if lResult.Failed {
				return FAIL
			}
			if !lResult.Types.Contains(values.BOOL) {
				cp.Throw("comp/bool/and/left", node.GetToken(), lResult.Types.describe(cp.Vm))
				return FAIL
			}
			leftRg := cp.That()
			if !lResult.Types.isOnly(values.BOOL) {
				if lResult.Types.Contains(values.ERROR) {
					leftError = cp.VmConditionalEarlyReturn(vm.Qtyp, leftRg, uint32(values.ERROR), leftRg)
				}
				if !lResult.Types.areOnly(values.BOOL, values.ERROR) {
					cp.ReserveError("vm/bool/and/left", node.Left.GetToken())
					leftTypecheck = cp.VmConditionalEarlyReturn(vm.Qntp, leftRg, uint32(values.BOOL), cp.That())
				}
			}
			checkLhs := cp.vmIf(vm.Qtru, leftRg)
			rResult := cp.CompileNode(node.Right, ctxt.x())
			if rResult.Failed {
				return FAIL
			}
			if !rResult.Types.Contains(values.BOOL) {
				cp.Throw("comp/bool/and/right", node.GetToken(), rResult.Types.describe(cp.Vm))
				return FAIL
			}
			rightRg := cp.That()
			if !rResult.Types.isOnly(values.BOOL) {
				if rResult.Types.Contains(values.ERROR) {
					rightError = cp.VmConditionalEarlyReturn(vm.Qtyp, rightRg, uint32(values.ERROR), rightRg)
				}
				if !rResult.Types.areOnly(values.BOOL, values.ERROR) {
					cp.ReserveError("vm/bool/and/right", node.Right.GetToken())
					rightTypecheck = cp.VmConditionalEarlyReturn(vm.Qntp, rightRg, uint32(values.BOOL), cp.That())
				}
			}
			cp.VmComeFrom(checkLhs)
			cp.Put(vm.Andb, leftRg, rightRg)
			cp.VmComeFrom(leftTypecheck, leftError, rightTypecheck, rightError)
			if lResult.Types.isOnly(values.BOOL) && rResult.Types.isOnly(values.BOOL) {
				result.Types = AltType(values.BOOL)
			} else {
				result.Types = AltType(values.BOOL, values.ERROR)
			}
			result.Foldable = lResult.Foldable && rResult.Foldable
			break
		}
		if node.Operator == ":" {
			if node.Left.GetToken().Type == token.ELSE {
				if cp.trackingOn(ctxt) || cp.autoOn(ctxt) {
					cp.TrackOrLog(vm.TR_ELSE, cp.trackingOn(ctxt), cp.autoOn(ctxt), &node.Token)
				}
				result = cp.CompileNode(node.Right, ctxt)
				if result.Failed {
					return FAIL
				}
				break NodeTypeSwitch
			}
			if cp.trackingOn(ctxt) || cp.autoOn(ctxt) {
				cp.TrackOrLog(vm.TR_CONDITION, cp.trackingOn(ctxt), cp.autoOn(ctxt), &node.Token, cp.P.PrettyPrint(node.Left))
			}
			lResult := cp.CompileNode(node.Left, ctxt.x())
			if lResult.Failed {
				return FAIL
			}
			if !lResult.Types.Contains(values.BOOL) {
				cp.Throw("comp/bool/cond", node.GetToken(), lResult.Types.describe(cp.Vm))
				return FAIL
			}
			if cp.trackingOn(ctxt) || cp.autoOn(ctxt) {
				cp.TrackOrLog(vm.TR_RESULT, cp.trackingOn(ctxt), cp.autoOn(ctxt), &node.Token, cp.That())
			}
			leftRg := cp.That()
			if !lResult.Types.isOnly(values.BOOL) {
				if lResult.Types.Contains(values.ERROR) {
					leftError = cp.VmConditionalEarlyReturn(vm.Qtyp, leftRg, uint32(values.ERROR), leftRg)
				}
				if !lResult.Types.areOnly(values.BOOL, values.ERROR) {
					cp.ReserveError("vm/bool/cond", node.Left.GetToken())
					leftTypecheck = cp.VmConditionalEarlyReturn(vm.Qntp, leftRg, uint32(values.BOOL), cp.That())
				}
			}
			checkLhs := cp.vmIf(vm.Qtru, leftRg)
			rResult := cp.CompileNode(node.Right, ctxt)
			if rResult.Failed {
				return FAIL
			}
			ifCondition := cp.vmEarlyReturn(cp.That())
			cp.VmComeFrom(checkLhs)
			cp.Put(vm.Asgm, values.C_UNSAT)
			cp.VmComeFrom(ifCondition, leftTypecheck, leftError)
			result.Foldable = lResult.Foldable && rResult.Foldable
			if lResult.Types.isOnly(values.BOOL) {
				result.Types = rResult.Types.Union(AltType(values.UNSATISFIED_CONDITIONAL))
			} else {
				result.Types = rResult.Types.Union(AltType(values.UNSATISFIED_CONDITIONAL, values.ERROR))
			}
			break
		}
		if node.Operator == ";" {
			lResult := cp.CompileNode(node.Left, ctxt)
			if lResult.Failed {
				return FAIL
			}
			leftRg := cp.That()
			// We deal with the case where the newline is separating local constant definitions
			// in the 'given' block.
			if lResult.Types.isOnly(values.CREATED_THUNK_OR_CONST) {
				rResult := cp.CompileNode(node.Right, ctxt)
				rResult = concResult(values.CREATED_THUNK_OR_CONST, lResult.Foldable && rResult.Foldable)
				break
			}
			// We may be executing a command.
			cmdRet := lResult.Types.IsLegalCmdReturn()
			if !cmdRet && !lResult.Types.Contains(values.UNSATISFIED_CONDITIONAL) {
				// TODO --- implement warnings.
				// cp.Throw("comp/unreachable", node.GetToken())
				// break
			}
			if cmdRet { // It could be error, break, OK, or an unsatisfied conditional.
				ifError := BkEarlyReturn(DUMMY)
				ifCouldBeUnsatButIsnt := BkEarlyReturn(DUMMY)
				if lResult.Types.Contains(values.ERROR) {
					ifError = cp.VmConditionalEarlyReturn(vm.Qtyp, leftRg, uint32(values.ERROR), leftRg)
				}
				if lResult.Types.Contains(values.UNSATISFIED_CONDITIONAL) && node.Right.GetToken().Type == token.COLON { // Then it is an else-less conditional or a try, and it it isn't UNSAT then we should skip the right node if it is a conditional.
					ifCouldBeUnsatButIsnt = cp.VmConditionalEarlyReturn(vm.Qntp, leftRg, uint32(values.UNSATISFIED_CONDITIONAL), leftRg)
				}
				rResult := cp.CompileNode(node.Right, ctxt) // In a cmd we wish rConst to remain false to avoid folding.
				if rResult.Failed {
					return FAIL
				}
				cp.VmComeFrom(ifError, ifCouldBeUnsatButIsnt)
				result.Foldable = lResult.Foldable && rResult.Foldable
				result.Types = lResult.Types.Union(rResult.Types)
				if colon, ok := node.Left.(*parser.LazyInfixExpression); ok {
					if colon.Left.GetToken().Type == token.ELSE {
						result.Types = rResult.Types.without(SimpleType(values.UNSATISFIED_CONDITIONAL))
					}
				}
			} else { // Otherwise it's functional.
				satJump := cp.vmIf(vm.Qsat, leftRg)
				lhsIsSat := cp.vmEarlyReturn(leftRg)
				cp.VmComeFrom(satJump)
				rResult := cp.CompileNode(node.Right, ctxt)
				if rResult.Failed {
					return FAIL
				}
				cp.Put(vm.Asgm, cp.That())
				cp.VmComeFrom(lhsIsSat)
				result.Foldable = lResult.Foldable && rResult.Foldable
				if !(lResult.Types.Contains(values.UNSATISFIED_CONDITIONAL) && rResult.Types.Contains(values.UNSATISFIED_CONDITIONAL)) {
					result.Types = lResult.Types.Union(rResult.Types).without(tp(values.UNSATISFIED_CONDITIONAL))
				} else {
					result.Types = lResult.Types.Union(rResult.Types)
				}
			}
		}
	case *parser.ListExpression:
		errCheck := BkEarlyReturn(DUMMY)
		containedResult := cp.CompileNode(node.List, ctxt.x())
		if containedResult.Failed {
			return FAIL
		}
		if containedResult.Types.isOnly(values.ERROR) {
			cp.Throw("comp/list/err", node.GetToken())
			return FAIL
		}
		if containedResult.Types.Contains(values.ERROR) {
			errCheck = cp.VmConditionalEarlyReturn(vm.Qtyp, cp.That(), uint32(values.ERROR), cp.That())
		}
		cp.Put(vm.List, cp.That())
		cp.VmComeFrom(errCheck)
		result = concResult(values.LIST, containedResult.Foldable)
		break
	case *parser.LogExpression:
		newCtxt := ctxt
		newCtxt.LogFlavor = LF_NONE
		ifRuntimeError := BkEarlyReturn(DUMMY)
		// TODO --- check if logging has been silenced by a flag.
		// A a user-defined logging statement can contain arbitrary expressions in the |...| delimiters which we
		// therefore need to compile like it was a snippet.
		if node.Value == "" {
			if node.Token.Type != token.PRELOG { // In which case autologging will have been taken care of when we started compiling the function.
				newCtxt.LogFlavor = LF_TRACK // This will ensure that autologging happens for the children of the LogExpression.
			}
		} else { // Otherwise the user has made their own logging statement.
			logCheck := cp.vmIf(vm.Qlog) // Skips over the logging if we are already in a logging statement, as explained below.
			cp.Emit(vm.Logn)             // 'logn' and 'logy' turn logging on and off respectively in the vm, to prevent us from logging the activities of functions called in compileLog and at worst facing an infinite regress.
			outputLoc, logMayHaveError, ok := cp.compileLog(node, ctxt)
			if !ok {
				return FAIL
			}
			cp.Emit(vm.Logy)
			cp.TrackOrLog(vm.TR_LITERAL, false, true, &node.Token, outputLoc)
			if logMayHaveError {
				ifRuntimeError = cp.VmConditionalEarlyReturn(vm.Qtyp, outputLoc, uint32(values.ERROR), cp.That())
			}
			cp.VmComeFrom(logCheck)
		}
		// Syntactically a log expression is attached to a normal expression, which we must now compile.
		switch node.GetToken().Type {
		case token.IFLOG:
			newToken := node.Token
			newToken.Literal = ":"
			newToken.Type = token.COLON
			newNode := &parser.LazyInfixExpression{newToken, node.Left, ":", node.Right}
			result = cp.CompileNode(newNode, newCtxt)
		case token.PRELOG:
			result = cp.CompileNode(node.Right, ctxt)
		default: // I.e. token.LOG.
			result = cp.CompileNode(node.Left, newCtxt)
		}
		if result.Failed {
			return FAIL
		}
		result.Foldable = false
		cp.VmComeFrom(ifRuntimeError)
		break
	case *parser.Nothing:
		cp.Put(vm.Asgm, values.C_EMPTY_TUPLE)
		result = cpResult{Types: AlternateType{FiniteTupleType{}}, Foldable: true}
	case *parser.PipingExpression: // I.e. -> >> and -> and ?> .
		lResult := cp.CompileNode(node.Left, ctxt.x())
		if lResult.Failed {
			return FAIL
		}
		// And that's about all the streaming operators really do have in common under the hood, so let's do a switch on the operators.
		var rResult cpResult
		switch node.Operator {
		case "->":
			rResult = cp.compilePipe(lResult.Types, lResult.Foldable, node.Right, env, ctxt)
		case ">>":
			rResult = cp.compileMappingOrFilter(lResult.Types, lResult.Foldable, node.Right, env, ctxt, false)
		default:
			rResult = cp.compileMappingOrFilter(lResult.Types, lResult.Foldable, node.Right, env, ctxt, true)
		}
		if rResult.Failed {
			return FAIL
		}
		result = cpResult{Types: rResult.Types, Foldable: lResult.Foldable && rResult.Foldable}
		break
	case *parser.PrefixExpression:
		if node.Token.Type == token.NOT {
			rResult := cp.CompileNode(node.Args[0], ctxt.x())
			if rResult.Failed {
				return FAIL
			}
			switch {
			case rResult.Types.isOnly(values.BOOL):
				cp.Put(vm.Notb, cp.That())
				result = concResult(values.BOOL, rResult.Foldable)
				break NodeTypeSwitch
			case rResult.Types.Contains(values.BOOL):
				boolLoc := cp.That()
				boolTest := cp.vmIf(vm.Qtyp, cp.That(), uint32(values.BOOL))
				errorLoc := cp.ReserveError("vm/bool/not", node.GetToken())
				cp.Put(vm.Notb, boolLoc)
				cp.Emit(vm.Jmp, cp.CodeTop()+2)
				cp.VmComeFrom(boolTest)
				cp.Emit(vm.Asgm, cp.That(), errorLoc)
				result = cpResult{Types: AltType(values.ERROR, values.BOOL), Foldable: rResult.Foldable}
				break NodeTypeSwitch
			default:
				cp.Throw("comp/bool/not", node.GetToken(), rResult.Types.describe(cp.Vm))
				return FAIL
			}
		}
		if node.Token.Type == token.VALID {
			rResult := cp.CompileNode(node.Args[0], ctxt.x())
			if rResult.Failed {
				return FAIL
			}
			cp.Put(vm.Vlid, cp.That())
			result = concResult(values.BOOL, rResult.Foldable)
			break
		}
		if node.Token.Type == token.UNWRAP {
			rResult := cp.CompileNode(node.Args[0], ctxt.x())
			if rResult.Failed {
				return FAIL
			}
			errTok := cp.ReserveToken(node.GetToken())
			cp.Put(vm.Uwrp, cp.That(), errTok)
			result = cpResult{Types: AltType(values.ERROR).Union(cp.GetAlternateTypeFromConcreteTypeName("Error")), Foldable: rResult.Foldable}
			break
		}
		if node.Token.Type == token.GLOBAL { // This is in effect a compiler directive, it doesn't need to emit any code besides `ok`, it just mutates the environment.
			for _, v := range node.Args {
				switch arg := v.(type) {
				case *parser.Identifier:
					variable, ok := cp.GlobalVars.GetVar(arg.Value)
					if !ok {
						cp.Throw("comp/global/global", arg.GetToken())
						return FAIL
					}
					env.Data[arg.Value] = *variable
				default:
					cp.Throw("comp/global/ident", arg.GetToken())
					return FAIL
				}
			}
			result = concResult(values.SUCCESSFUL_VALUE, false) // Obviously we don't want to fold away the assignment.
			break
		}
		if node.Token.Type == token.BREAK {
			if !cp.forDataExists() { // Then we're not in a 'for' loop.
				cp.Throw("comp/break/a", node.GetToken())
				return FAIL
			}
			result = cp.CompileNode(node.Args[0], ctxt)
			if result.Failed {
				return FAIL
			}
			result.Foldable = false // Or it might try to break out of the loop at compile time.
			cp.addToForData(cp.vmBreakWithValue(cp.That()))
			break
		}
		resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
		if cp.P.ErrorsExist() {
			break
		}
		var (
			v  *Variable
			ok bool
		)
		if resolvingCompiler != cp {
			v, ok = resolvingCompiler.GlobalConsts.GetVar(node.Operator)
		} else {
			v, ok = env.GetVar(node.Operator)
		}
		if ok { // Then it is a variable which may contain a function which may or may not be wrapped in a thunk.
			cp.Cm("Prefix is variable which may contain a lambda.", node.GetToken())
			recursion := false
			if v.Access == LOCAL_FUNCTION_THUNK || v.Access == LOCAL_FUNCTION_CONSTANT {
				if cp.Vm.Mem[v.MLoc].V == nil { // Then it's uninitialized because we're doing recursion in a given block and we haven't compiled that function yet.
					cp.PushMem(cp.CodeTop())
					cp.Emit(vm.Rpsh, cp.getLambdaStart(), cp.MemTop())
					recursion = true
				}
			}
			if v.Access == LOCAL_VARIABLE_THUNK || v.Access == LOCAL_FUNCTION_THUNK {
				cp.Cm("Prefix variable is thunked. Unthunking.", node.GetToken())
				cp.Emit(vm.Untk, v.MLoc)
			}
			operands := []uint32{v.MLoc}
			for _, arg := range node.Args {
				typeResult := cp.CompileNode(arg, ctxt.x())
				if typeResult.Failed {
					return FAIL
				}
				operands = append(operands, cp.That())
			}
			switch {
			case v.Types.isOnly(values.FUNC):
				cp.Cm("Prefix variable can only be lambda.", node.GetToken())
				cp.Put(vm.Dofn, operands...)
				if recursion {
					cp.Emit(vm.Rpop)
				}
			case v.Types.Contains(values.FUNC):
				errorLoc := cp.ReserveError("vm/apply/func", node.GetToken(), v.MLoc)
				cp.Cm("Prefix variable might be lambda. Emitting type check.", node.GetToken())
				funcTest := cp.vmIf(vm.Qtyp, v.MLoc, uint32(values.FUNC))
				cp.Put(vm.Dofn, operands...)
				if recursion {
					cp.Emit(vm.Rpop)
				}
				cp.Emit(vm.Jmp, cp.CodeTop()+2)
				cp.VmComeFrom(funcTest)
				cp.Emit(vm.Asgm, cp.That(), errorLoc)
			default:
				cp.Cm("Prefix variable cannot be lambda. Throwing error.", node.GetToken())
				cp.Throw("comp/apply/func", node.GetToken(), node.Operator)
				break NodeTypeSwitch
			}
			result = cpResult{Types: cp.Common.AnyTypeScheme}
			break NodeTypeSwitch
		}
		ok, _ = cp.P.CanParse(node.Token, parser.PREFIX)
		if ok || resolvingCompiler.P.Functions.Contains(node.Operator) {
			cp.pushRCompiler(resolvingCompiler)
			result = resolvingCompiler.createFunctionCall(cp, node, ctxt.x(), node.GetToken().Namespace != "")
			if result.Failed {
				return FAIL
			}
			cp.popRCompiler()
			break
		}
		cp.Throw("comp/known/prefix", node.GetToken())
	case *parser.RuneLiteral:
		cp.Reserve(values.RUNE, node.Value, node.GetToken())
		result = concResult(values.RUNE, true)
	case *parser.SnippetLiteral:
		snF := cp.reserveSnippetFactory(env, node, ctxt)
		if snF == DUMMY {
			return FAIL
		}
		cp.Put(vm.MkSn, snF)
		result = concResult(values.SNIPPET, false)
	case *parser.StringLiteral:
		cp.Reserve(values.STRING, node.Value, node.GetToken())
		result = concResult(values.STRING, true)
	case *parser.SuffixExpression:
		resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
		if node.GetToken().Type == token.DOTDOTDOT {
			if len(node.Args) != 1 {
				cp.Throw("comp/splat/args", node.GetToken())
				break NodeTypeSwitch
			}
			lResult := cp.CompileNode(node.Args[0], ctxt.x())
			overlap := lResult.Types.intersect(cp.Common.SharedTypenameToTypeList["clones{list}"])
			if len(overlap) == 0 {
				cp.Throw("comp/splat/type", node.GetToken(), lResult.Types.describe(cp.Vm))
				return FAIL
			}
			if len(lResult.Types) == len(overlap) {
				cp.Put(vm.TupL, cp.That())
				result = concResult(values.TUPLE, lResult.Foldable)
				break NodeTypeSwitch
			}
			cp.Put(vm.TuLx, cp.That(), cp.ReserveToken(node.Args[0].GetToken()))
			result = cpResult{Types: altType(values.ERROR, values.TUPLE), Foldable: lResult.Foldable}
			break NodeTypeSwitch
		}
		cp.pushRCompiler(resolvingCompiler)
		result = resolvingCompiler.createFunctionCall(cp, node, ctxt.x(), node.GetToken().Namespace != "")
		cp.popRCompiler()
		if result.Failed {
			return FAIL
		}
	case *parser.TryExpression:
		// We may have a variable to store an identifier in, which may or may not already have
		// been declared.
		ident := node.VarName
		v, exists := env.GetVar(ident)
		if exists && (v.Access == GLOBAL_CONSTANT_PRIVATE || v.Access == GLOBAL_CONSTANT_PUBLIC || v.Access == GLOBAL_VARIABLE_PRIVATE ||
			v.Access == GLOBAL_VARIABLE_PUBLIC || v.Access == LOCAL_VARIABLE_THUNK || v.Access == LOCAL_FUNCTION_THUNK) {
			cp.Throw("comp/try/var", node.GetToken())
			break
		}
		var err uint32
		if !exists {
			err = cp.Reserve(values.NULL, nil, node.GetToken())
			cp.AddThatAsVariable(env, ident, LOCAL_VARIABLE, AltType(values.NULL, values.ERROR), node.GetToken())
		} else {
			err = v.MLoc
		}
		// Now we compile the expression we're `try`ing.
		tryResult := cp.CompileNode(node.Right, ctxt.x())
		if tryResult.Failed {
			return FAIL
		}
		if tryResult.Types.IsNoneOf(values.ERROR, values.SUCCESSFUL_VALUE) {
			cp.Throw("comp/try/return", node.GetToken())
			break
		}
		// And now we execute the `try` logic, i.e. if the result `cp.That()` was an error, then
		// we stash the error away in the place we just reserved for it, and replace it with
		// an unsatisfied conditional.
		cp.Emit(vm.Qtyp, cp.That(), uint32(values.ERROR), cp.CodeTop()+3)
		cp.Emit(vm.Asgm, err, cp.That())
		cp.Emit(vm.Asgm, cp.That(), values.C_UNSAT)
		// So now the result is either a `SUCCESSFUL_VALUE` if the operation succeeded, or an
		// `UNSATISFIED_CONDITIONAL` if it didn't.
		result = cpResult{Types: AltType(values.UNSATISFIED_CONDITIONAL, values.SUCCESSFUL_VALUE)}
	case *parser.TypeExpression:
		resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
		if len(node.TypeArgs) == 0 {
			abType := resolvingCompiler.GetAbstractTypeFromTypeName(node.Operator, node.Token)
			if (ac == REPL || resolvingCompiler != cp) && cp.IsPrivate(abType) {
				cp.Throw("comp/private/type", node.GetToken())
				return FAIL
			}
			cp.Reserve(values.TYPE, abType, node.GetToken())
			result = concResult(values.TYPE, true)
		} else {
			if node.Operator == "clones" {
				if len(node.TypeArgs) != 1 {
					cp.Throw("comp/clones/arguments", node.GetToken())
					break NodeTypeSwitch
				}
				argResult := cp.CompileNode(node.TypeArgs[0], ctxt.x())
				if argResult.Failed {
					return FAIL
				}
				if !argResult.Types.Contains(values.TYPE) {
					cp.Throw("comp/clones", node.GetToken())
					break NodeTypeSwitch
				}
				cp.Put(vm.Clon, cp.That(), cp.ReserveToken(node.GetToken()))
				result = concResult(values.TYPE, true)
				break NodeTypeSwitch
			}
			result = cpResult{Types: AltType(values.ERROR, values.TYPE), Foldable: true}
			cp.ReserveToken(node.GetToken())
			argsForVm := []uint32{resolvingCompiler.P.ParTypes[node.Operator].VmTypeInfo, cp.ThatToken()}
			for _, arg := range node.TypeArgs {
				argResult := cp.CompileNode(arg, ctxt.x())
				if argResult.Failed {
					return FAIL
				}
				argsForVm = append(argsForVm, cp.That())
				result.Foldable = result.Foldable && argResult.Foldable
			}
			cp.Put(vm.Mpar, argsForVm...)
		}
	case *parser.TypePrefixExpression: // TODO --- since this ends up as a PrefixExpression eventually, could it not start off as one?
		if len(node.TypeArgs) == 0 {
			constructor := &parser.PrefixExpression{node.Token, node.Operator, node.Args}
			resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
			if abType := resolvingCompiler.GetAbstractTypeFromTypeName(node.Operator, node.Token); abType.Len() != 1 {
				cp.Throw("comp/type/concrete", node.GetToken())
				return FAIL
			}
			result = cp.CompileNode(constructor, ctxt)
			if result.Failed {
				return FAIL
			}
		} else {
			// This is where we do the magic that turns `Z{foo}(bar)` into `Z{Z{foo}, bar}`.
			typeNode := &parser.TypeExpression{Token: node.Token, Operator: node.Operator, TypeArgs: node.TypeArgs}
			argsWithType := append([]parser.Node{typeNode}, node.Args...)
			node.Token.Literal = node.Token.Literal + "{}" // TODO --- this is heinous. Anything looking at a PrefixExpression should be looking at the operator, not the token literal.
			constructor := &parser.PrefixExpression{node.Token, node.Operator + "{}", argsWithType}
			result = cp.CompileNode(constructor, ctxt)
			if result.Failed {
				return FAIL
			}
		}
	case *parser.TypeSuffixExpression: // Clone types can have type suffixes as constructors so you can use them as units.
		if ty, ok := node.Operator.(*parser.TypeWithName); ok {
			// The fact that we're compiling this node means that we're not in a signature. Hence
			// the compiler can do what the parser can't, and turn it into a normal suffix expression,
			// which can then be compiled.
			suffix := &parser.SuffixExpression{node.Token, ty.OperatorName, node.Args}
			resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
			result = resolvingCompiler.CompileNode(suffix, ctxt)
			if result.Failed {
				return FAIL
			}
		} else {
			cp.Throw("comp/suffix/b", node.GetToken())
			return FAIL
		}
	case *parser.UnfixExpression:
		resolvingCompiler := cp.getResolvingCompiler(node.GetToken(), ac)
		result = resolvingCompiler.createFunctionCall(resolvingCompiler, node, ctxt.x(), len(node.Namespace) > 0)
		if result.Failed {
			return FAIL
		}
	default:
		panic("Unimplemented node type " + reflect.TypeOf(node).String() + " at line " + strconv.Itoa(node.GetToken().Line) + " of " + node.GetToken().Source)
	}

	// We're done with the typeswitch. We perform some sanity checks to ensure that our functions aren't behaving
	// like commands or vice versa.
	if result.Failed {
		return FAIL
	}
	if result.Foldable {
		cp.Cm("Expression "+node.String()+" is foldable with return types "+result.Types.describe(cp.Vm)+".", node.GetToken())
	} else {
		cp.Cm("Expression "+node.String()+" is unfoldable with return types "+result.Types.describe(cp.Vm)+".", node.GetToken())
	}
	if !result.Types.IsLegalCmdReturn() && !result.Types.IsLegalDefReturn() {
		cp.Throw("comp/sanity", node.GetToken())
		return FAIL
	}
	if ac == DEF && !result.Types.IsLegalDefReturn() {
		cp.Throw("comp/fcis", node.GetToken())
		return FAIL
	}
	// If the node we evaluated is potentially a return value of a function we're compiling, then
	// if the function has return types this is where we can check if they've been violated.
	if ctxt.IsReturn && !cp.checkInferredTypesAgainstContext(result.Types, ctxt.Typecheck, node.GetToken()) {
		return FAIL
	}
	// We do a little logging.
	_, isLazyInfix := node.(*parser.LazyInfixExpression)
	_, isLoggingOperation := node.(*parser.LogExpression)
	if !(isLazyInfix || isLoggingOperation) && (cp.trackingOn(ctxt) || cp.autoOn(ctxt)) && ac == DEF {
		cp.TrackOrLog(vm.TR_RETURN, cp.trackingOn(ctxt), cp.autoOn(ctxt), node.GetToken(), ctxt.FName, cp.That())
		result.Foldable = false // 'false' because we don't want to fold away the tracking information. TODO --- is this redundant?
		return result
	}
	// If we have a foldable constant, we run the code, roll back the vm, and put the result we got
	// from the code on top of memory.
	if result.Foldable && (!result.Types.hasSideEffects()) && cp.CodeTop() > cT {
		cp.Emit(vm.Ret)
		cp.Cm("Calling Run from end of CompileNode as part of routine constant folding.", node.GetToken())
		cp.Vm.Run(cT)
		val := cp.Vm.Mem[cp.That()]
		if val.T == values.TUPLE {
			tType := FiniteTupleType{}
			for _, v := range val.V.([]values.Value) {
				tType = append(tType, SimpleType(v.T))
			}
			result.Types = AlternateType{tType}
		} else {
			result.Types = AltType(val.T)
		}
		cp.Rollback(state, node.GetToken())
		cp.Reserve(val.T, val.V, node.GetToken())
	}
	return result
}

// A function auxiliary to the previous one that checks the return types of a function.
func (cp *Compiler) checkInferredTypesAgainstContext(rtnTypes AlternateType, typecheck FiniteTupleType, tok *token.Token) bool {
	if len(typecheck) == 0 {
		return true
	}
	singles, _ := rtnTypes.splitSinglesAndTuples()
	typeLengths := lengths(rtnTypes)
	if (!(typeLengths.Contains(-1) || typeLengths.Contains(len(typecheck)))) &&
		!(singles.areOnly(values.ERROR, values.UNSATISFIED_CONDITIONAL)) {
		cp.Throw("comp/return/length", tok, rtnTypes.describe(cp.Vm), typecheck.describe(cp.Vm))
		return false
	}
	for i, ty := range typecheck {
		intersection := ty.(AlternateType).intersect(typesAtIndex(rtnTypes, i))
		if len(intersection) == 0 && !rtnTypes.areOnly(values.ERROR, values.UNSATISFIED_CONDITIONAL) {
			cp.Throw("comp/return/types", tok, rtnTypes.without(SimpleType(values.ERROR)).describe(cp.Vm), typecheck.describe(cp.Vm))
			return false
		}
	}
	return true
}

// Function auxiliary to CompileNode that finds the appropriate compiler for a given namespace.
func (cp *Compiler) getResolvingCompiler(tok *token.Token, ac CpAccess) *Compiler {
	namespace := []string{}
	if tok.Namespace == "" {
		return cp
	} else {
		namespace = strings.Split(tok.Namespace, ".")
	}
	resolvingCompiler := cp
	for _, name := range namespace[:len(namespace)-1] {
		// We checked that it exists during parsing.
		resolvingCompiler, _ = resolvingCompiler.Modules[name]
		if resolvingCompiler.P.Private && (ac == REPL || len(namespace) > 1) {
			cp.Throw("comp/namespace/private", tok, name)
			return nil
		}
	}
	return resolvingCompiler
}

// This function compiles a comma, i.e. the thing that concatenates values into tuples.
// This needs its own very special logic because the typescheme it returns has to be composed in a different
// way from all the other operators.
func (cp *Compiler) compileComma(node *parser.InfixExpression, ctxt Context) cpResult {
	lResult := cp.CompileNode(node.Args[0], ctxt.x())
	if lResult.Failed {
		return FAIL
	}
	if lResult.Types.isOnly(values.ERROR) {
		cp.Throw("comp/tuple/err/a", node.GetToken())
		return FAIL
	}
	left := cp.That()
	rResult := cp.CompileNode(node.Args[2], ctxt.x())
	if rResult.Failed {
		return FAIL
	}
	if rResult.Types.isOnly(values.ERROR) {
		cp.Throw("comp/tuple/err/b", node.GetToken())
		return FAIL
	}
	right := cp.That()
	leftIsError := BkEarlyReturn(DUMMY)
	rightIsError := BkEarlyReturn(DUMMY)
	if lResult.Types.Contains(values.ERROR) {
		leftIsError = cp.VmConditionalEarlyReturn(vm.Qtyp, left, uint32(values.ERROR), left)
	}
	if rResult.Types.Contains(values.ERROR) {
		rightIsError = cp.VmConditionalEarlyReturn(vm.Qtyp, right, uint32(values.ERROR), right)
	}
	leftMustBeSingle, leftMustBeTuple := lResult.Types.mustBeSingleOrTuple()
	rightMustBeSingle, rightMustBeTuple := rResult.Types.mustBeSingleOrTuple()
	switch {
	case leftMustBeSingle && rightMustBeSingle:
		cp.Put(vm.Cc11, left, right)
	case leftMustBeSingle && rightMustBeTuple:
		cp.Put(vm.Cc1T, left, right)
	case leftMustBeTuple && rightMustBeSingle:
		cp.Put(vm.CcT1, left, right)
	case leftMustBeTuple && rightMustBeTuple:
		cp.Put(vm.CcTT, left, right)
	default:
		cp.Put(vm.Ccxx, left, right) // We can after all let the operation dispatch for us.
	}
	cp.VmComeFrom(leftIsError, rightIsError)
	lT := lResult.Types.reduce()
	rT := rResult.Types.reduce()
	cst := lResult.Foldable && rResult.Foldable
	switch lT := lT.(type) {
	case FiniteTupleType:
		switch rT := rT.(type) {
		case FiniteTupleType:
			return cpResult{Types: AlternateType{append(lT, rT...)}, Foldable: cst}
		case TypedTupleType:
			return cpResult{Types: AlternateType{TypedTupleType{rT.T.Union(getAllTypes(lT))}}, Foldable: cst}
		case SimpleType:
			return cpResult{Types: AlternateType{FiniteTupleType{append(lT, rT)}}, Foldable: cst}
		case AlternateType:
			return cpResult{Types: AlternateType{FiniteTupleType{append(lT, rT)}}, Foldable: cst} // TODO --- check if this works.
		default:
			panic("We shouldn't be here!")
		}
	case TypedTupleType:
		switch rT := rT.(type) {
		case FiniteTupleType:
			return cpResult{Types: AlternateType{TypedTupleType{lT.T.Union(getAllTypes(rT))}}, Foldable: cst}
		case TypedTupleType:
			return cpResult{Types: AlternateType{TypedTupleType{lT.T.Union(rT.T)}}, Foldable: cst}
		case SimpleType:
			return cpResult{Types: AlternateType{TypedTupleType{lT.T.Union(AlternateType{rT})}}, Foldable: cst}
		case AlternateType:
			return cpResult{Types: AlternateType{TypedTupleType{lT.T.Union(getAllTypes(rT))}}, Foldable: cst}
		default:
			panic("We shouldn't be here!")
		}
	case SimpleType:
		switch rT := rT.(type) {
		case FiniteTupleType:
			return cpResult{Types: AlternateType{append(FiniteTupleType{lT}, rT...)}, Foldable: cst}
		case TypedTupleType:
			return cpResult{Types: AlternateType{TypedTupleType{rT.T.Union(AlternateType{lT})}}, Foldable: cst}
		case SimpleType:
			return cpResult{Types: AlternateType{FiniteTupleType{lT, rT}}, Foldable: cst}
		case AlternateType:
			return cpResult{Types: AlternateType{FiniteTupleType{lT, rT}}, Foldable: cst}
		default:
			panic("We shouldn't be here!")
		}
	case AlternateType:
		switch rT := rT.(type) {
		case FiniteTupleType:
			return cpResult{Types: AlternateType{append(FiniteTupleType{lT}, rT...)}, Foldable: cst}
		case TypedTupleType:
			return cpResult{Types: AlternateType{TypedTupleType{rT.T.Union(lT)}}, Foldable: cst}
		case SimpleType:
			return cpResult{Types: AlternateType{FiniteTupleType{lT, rT}}, Foldable: cst}
		case AlternateType:
			return cpResult{Types: AlternateType{FiniteTupleType{lT, rT}}, Foldable: cst}
		default:
			panic("We shouldn't be here!")
		}
	default:
		panic("We shouldn't be here!")
	}
}

// A type to support the following function.
type loopFlavor int

const (
	UNDEFINED_LOOP_FLAVOR loopFlavor = iota
	TRIPARTITE
	WHILE
	INFINITE_LOOP
	RANGE
)

// Compiles the various flavors of `for` loop.
// We have four cases.
// (i) The 'for' loop has a C-like tripartite header.
// (ii) The 'for' loop is acting as a 'while' loop and so just has a conditional.
// (iii) It doesn't even have a conditional, and can be exited only with break.
// (iv) The 'for' loop is of the form x::y = range z
func (cp *Compiler) compileForExpression(node *parser.ForExpression, ctxt Context) cpResult {
	tok := &node.Token
	cp.Cm("Called compileForExpression", tok)
	// The 'flavor' flag allows us to keep track of what kind of `for` loop we're compiling.
	flavor := UNDEFINED_LOOP_FLAVOR
	hasBoundVariables := false
	var keysOnly, valuesOnly bool     // Only applies to range-style loops.
	rangeKeyLoc := uint32(DUMMY)      //          "
	rangeValLoc := uint32(DUMMY)      //          "
	iteratorLoc := uint32(DUMMY)      //          "
	rangeOver := BkEarlyReturn(DUMMY) //      "

	// The parser so far has only broken the header up into its parts, but has not validated
	// that they're in the proper form.

	newEnv := &Environment{map[string]Variable{}, ctxt.Env}
	newContext := ctxt.x()
	newContext.Env = newEnv

	// First we set up the bound variables.

	boundResultLoc := uint32(DUMMY)
	indexResultLoc := uint32(DUMMY)
	var boundCpSig, indexCpSig alternateSig
	var boundVariableTypes, indexVariableTypes AlternateType

	if node.BoundVariables == nil {
		if ctxt.Access != CMD && ctxt.Access != REPL {
			cp.Throw("comp/for/bound/present", &node.Token)
			return FAIL
		}
		cp.Reserve(values.UNDEFINED_TYPE, nil, node.GetToken()) // If we don't have any bound variables, then this is presumptively an imperative loop and we'll need somewhere to put OK/break/error still.
		boundResultLoc = cp.That()
	} else {
		hasBoundVariables = true
		// We set up the bound variables. Note that type checking happens *inside* the 'for' loop, not up here.
		if node.BoundVariables.GetToken().Type != token.ASSIGN {
			cp.Throw("comp/for/assign/a", &node.Token)
			return FAIL
		}
		lhsOfBoundVariables := node.BoundVariables.(*parser.AssignmentExpression).Left
		rhsOfBoundVariables := node.BoundVariables.(*parser.AssignmentExpression).Right
		boundSig, ok := cp.P.ReparseSig(lhsOfBoundVariables, parser.DEFAULT_TYPE_AST)
		if !ok {
			return FAIL
		}
		cp.Cm("Finding initial values of bound variables", tok)
		boundCpResult := cp.CompileNode(rhsOfBoundVariables, ctxt)
		if boundCpResult.Failed {
			return FAIL
		}
		boundVariableTypes = boundCpResult.Types
		newContext.ForReturns = boundVariableTypes
		if boundCpResult.Foldable { // Then we still need to initialize the index variables when we start the loop.
			cp.Put(vm.Asgm, cp.That())
		}
		boundResultLoc = cp.That()
		for i, pair := range boundSig {
			_, exists := newEnv.GetVar(pair.VarName)
			if exists {
				cp.Throw("comp/for/bound/exists", node.BoundVariables.GetToken())
				return FAIL
			}
			cp.Reserve(values.UNDEFINED_TYPE, nil, tok)
			var types AlternateType
			if pair.VarType == parser.DEFAULT_TYPE_AST {
				types = typesAtIndex(boundVariableTypes, i)
			} else {
				types = cp.GetAlternateTypeFromTypeAst(pair.VarType)
			}
			cp.AddThatAsVariable(newEnv, pair.VarName, FOR_LOOP_BOUND_VARIABLE, types, tok)
			boundCpSig = append(boundCpSig, NameAlternateTypePair{pair.VarName, types})
		}
	}

	// Now the variables for the header, if any.
	switch {
	case node.Initializer != nil: // Then we have a C-like tripartite header.
		flavor = TRIPARTITE
		// For the initializer we have to do something very un-DRYly like what we just did with the bound variables; TODO ---
		// is there any way to DRY it up that doesn't obfuscate the code?
		if node.Initializer.GetToken().Type != token.ASSIGN {
			cp.Throw("comp/for/assign/b", &node.Token)
			return FAIL
		}
		lhsOfInitVariables := node.Initializer.(*parser.AssignmentExpression).Left
		rhsOfInitVariables := node.Initializer.(*parser.AssignmentExpression).Right
		indexSig, ok := cp.P.ReparseSig(lhsOfInitVariables, parser.DEFAULT_TYPE_AST)
		if !ok {
			return FAIL
		}
		cp.Cm("Finding initial values of index variables", tok)
		indexCpResult := cp.CompileNode(rhsOfInitVariables, ctxt)
		if indexCpResult.Failed {
			return FAIL
		}
		indexVariableTypes = indexCpResult.Types
		if indexCpResult.Foldable { // Then we still need to initialize the index variables when we start the loop.
			cp.Put(vm.Asgm, cp.That())
		}
		indexResultLoc = cp.That()
		for i, pair := range indexSig {
			_, exists := newEnv.GetVar(pair.VarName)
			if exists {
				cp.Throw("comp/for/exists/index", node.Initializer.GetToken(), pair.VarName)
				return FAIL
			}
			cp.Reserve(values.UNDEFINED_TYPE, nil, tok)
			var types AlternateType
			if pair.VarType == parser.DEFAULT_TYPE_AST {
				types = typesAtIndex(indexVariableTypes, i)
			} else {
				types = cp.GetAlternateTypeFromTypeAst(pair.VarType)
			}
			cp.AddThatAsVariable(newEnv, pair.VarName, FOR_LOOP_INDEX_VARIABLE, types, tok)
			indexCpSig = append(indexCpSig, NameAlternateTypePair{pair.VarName, types})
		}
	case node.ConditionOrRange == nil:
		flavor = INFINITE_LOOP
	case node.ConditionOrRange.GetToken().Type == token.ASSIGN: // Then we should have a 'range' expression, which we can deconstruct.
		flavor = RANGE
		pairOfIdentifiers := node.ConditionOrRange.(*parser.AssignmentExpression).Left
		rangeExpression := node.ConditionOrRange.(*parser.AssignmentExpression).Right
		if pairOfIdentifiers, ok := pairOfIdentifiers.(*parser.InfixExpression); ok && pairOfIdentifiers.Operator == "::" {
			var leftName, rightName string
			if leftId, ok := pairOfIdentifiers.Args[0].(*parser.Identifier); ok {
				leftName = leftId.Value
			} else {
				cp.Throw("comp/for/range/a", node.GetToken())
				return FAIL
			}
			if rightId, ok := pairOfIdentifiers.Args[2].(*parser.Identifier); ok {
				rightName = rightId.Value
			} else {
				cp.Throw("comp/for/range/b", node.GetToken())
				return FAIL
			}
			keysOnly = rightName == "_"
			valuesOnly = leftName == "_"
			if keysOnly && valuesOnly {
				cp.Throw("comp/for/range/discard", node.GetToken())
				return FAIL
			}
			var rangeOver parser.Node
			if rangeExpression, ok := rangeExpression.(*parser.PrefixExpression); ok && rangeExpression.Operator == "range" {
				rangeOver = rangeExpression.Args[0]
				rangeCpResult := cp.CompileNode(rangeOver, ctxt.x())
				if len(rangeCpResult.Types.intersect(cp.Common.IsRangeable)) == 0 && !rangeCpResult.Types.Contains(values.TUPLE) { // Note that 'Contains' special-cases tuples.
					cp.Throw("comp/for/range/types", node.GetToken())
					return FAIL
				}
				keysInt := uint32(0)
				if keysOnly {
					keysInt = 1
				}
				cp.Put(vm.Mkit, cp.That(), keysInt, cp.ReserveToken(rangeOver.GetToken())) // TODO --- optimize constant case.
				iteratorLoc = cp.That()
				if !valuesOnly {
					cp.Reserve(values.UNDEFINED_TYPE, nil, rangeOver.GetToken())
					rangeKeyLoc = cp.That()
					_, exists := newEnv.GetVar(leftName)
					if exists {
						cp.Throw("comp/for/exists/key", rangeOver.GetToken(), leftName)
						return FAIL
					}
					cp.AddThatAsVariable(newEnv, leftName, FOR_LOOP_INDEX_VARIABLE, cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST), rangeOver.GetToken()) // TODO --- narrow down.
				}
				if !keysOnly {
					cp.Reserve(values.UNDEFINED_TYPE, nil, rangeOver.GetToken())
					rangeValLoc = cp.That()
					_, exists := newEnv.GetVar(rightName)
					if exists {
						cp.Throw("comp/for/exists/value", rangeOver.GetToken(), rightName)
						return FAIL
					}
					cp.AddThatAsVariable(newEnv, rightName, FOR_LOOP_INDEX_VARIABLE, cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST), rangeOver.GetToken())
				}
			}
		} else {
			cp.Throw("comp/for/range/c", node.GetToken())
			return FAIL
		}
	default:
		flavor = WHILE
	} // end of switch

	saveThunkList := cp.ThunkList // TODO --- I really must stop doing that.
	cp.ThunkList = []ThunkData{}

	if node.Given == nil {
		cp.Cm("The 'given' block of the 'for' loop is nil.", tok)
	} else {
		jumpOverGiven := cp.vmGoTo() // The 'given' block needs to be compiled here but should of course only have parts executed on demand.
		cp.Cm("Compiling the 'given' block of the 'for' loop", tok)
		cp.CompileGivenBlock(node.Given, newContext)
		cp.VmComeFrom(jumpOverGiven)
	}

	boundInitCheck := BkEarlyReturn(DUMMY)
    indexInitCheck := BkEarlyReturn(DUMMY)
	boundUpdateCheck := BkEarlyReturn(DUMMY)
    indexUpdateCheck := BkEarlyReturn(DUMMY)
	conditionalFails := BkEarlyReturn(DUMMY)

	// We typecheck the initial values.
	if hasBoundVariables {
		cp.Cm("Typechecking bound variable result and putting it into bound variables.", tok)
		boundInitCheck = cp.EmitTypeChecks(boundResultLoc, boundVariableTypes, newEnv, boundCpSig, tok, CHECK_LOOP_VARIABLE_ASSIGNMENTS)
	}
	if flavor == TRIPARTITE {
		cp.Cm("Typechecking index variable result and putting it into index variables.", tok)
		indexInitCheck = cp.EmitTypeChecks(indexResultLoc, indexVariableTypes, newEnv, indexCpSig, tok, CHECK_LOOP_VARIABLE_ASSIGNMENTS)
	}


	startOfForLoop := cp.CodeTop()

	// The conditional for ending the loop, according to the flavor of the loop.
	if flavor == TRIPARTITE || flavor == WHILE {
		cp.Cm("Compiling conditional.", tok)
		conditionalCpResult := cp.CompileNode(node.ConditionOrRange, newContext)
		if conditionalCpResult.Failed {
			return FAIL
		}
		conditionalFails = cp.VmConditionalEarlyReturn(vm.Qfls, cp.That(), boundResultLoc)
	}
	if flavor == RANGE {
		rangeOver = cp.VmConditionalEarlyReturn(vm.Qitr, iteratorLoc, boundResultLoc)
		switch {
		case keysOnly:
			cp.Emit(vm.Itgk, rangeKeyLoc, iteratorLoc)
		case valuesOnly:
			cp.Emit(vm.Itgv, rangeValLoc, iteratorLoc)
		default:
			cp.Emit(vm.Itkv, rangeKeyLoc, rangeValLoc, iteratorLoc)
		}
	}
	// Now we get to emit the loop body, which is the same whatever the flavor of loop.
	cp.Cm("Compiling loop body.", tok)
	cp.pushNewForData()

	cp.Cm("Setting up thunks for the locals in the given block, if any.", tok)
	for _, thunk := range cp.ThunkList {
		cp.Emit(vm.Thnk, thunk.Dest, thunk.Value.MLoc, thunk.Value.CAddr)
	}
	cp.ThunkList = saveThunkList

	bodyCpResult := cp.CompileNode(node.Body, newContext)
	if bodyCpResult.Failed {
		return FAIL
	}
	cp.Emit(vm.Asgm, boundResultLoc, cp.That())
	if hasBoundVariables {
		cp.Cm("Typechecking bound variable result and putting it into bound variables.", tok)
		boundUpdateCheck = cp.EmitTypeChecks(boundResultLoc, bodyCpResult.Types, newEnv, boundCpSig, tok, CHECK_LOOP_VARIABLE_ASSIGNMENTS)
	}
	// Any 'continue' statements we've emitted are in the compiler's forData.
	cp.resolveContinues()
	// And then the iterator, which again differs according to the flavor.
	if flavor == TRIPARTITE {
		cp.Cm("Compiling iterator for loop with tripartite header.", tok)
		iteratorCpResult := cp.CompileNode(node.Update, newContext)
		if iteratorCpResult.Failed {
			return FAIL
		}
		cp.Cm("Typechecking index variable result and putting it into index variables.", tok)
		indexUpdateCheck = cp.EmitTypeChecks(cp.That(), iteratorCpResult.Types, newEnv, indexCpSig, tok, CHECK_LOOP_VARIABLE_ASSIGNMENTS)
	}

	// And we jump to the start of the loop.
	cp.Cm("Jumping to start of loop again.", tok)
	cp.Emit(vm.Jmp, startOfForLoop)
	// When we break out of the loop, we just need to put the result (in the bound variables) on top of memory.
	cp.Cm("Putting result on top of memory.", tok)
	cp.resolveBreaksWithoutValue()
	cp.Put(vm.Asgm, boundResultLoc)
	cp.resolveBreaksWithValue()
	cp.VmComeFrom(conditionalFails, rangeOver, boundInitCheck, indexInitCheck, boundUpdateCheck, indexUpdateCheck)
	bodyCpResult.Foldable = false
	return bodyCpResult
}

// Some auxilliary functiona for the `for` loops.

func (cp *Compiler) pushNewForData() {
	cp.forData = append(cp.forData, []any{})
}

// Takes the continues out of the top of the for stack and resolves them, leaves the breaks.
func (cp *Compiler) resolveContinues() {
	for _, item := range cp.forData[len(cp.forData)-1] {
		if item, ok := item.(bkContinue); ok {
			cp.VmComeFrom(item)
		}
	}
}

// Resolves the plain `break` statements where the loop returns the bound variables.
func (cp *Compiler) resolveBreaksWithoutValue() {
	for _, item := range cp.forData[len(cp.forData)-1] {
		if item, ok := item.(bkBreakWithoutValue); ok {
			cp.VmComeFrom(item)
		}
	}
}

// Resolves the `break` statements of the form `break <args>` which tell the loop what to return.
func (cp *Compiler) resolveBreaksWithValue() {
	for _, item := range cp.forData[len(cp.forData)-1] {
		if item, ok := item.(bkBreakWithValue); ok {
			cp.VmComeFrom(item)
		}
	}
	cp.forData = cp.forData[:len(cp.forData)-1] // As this is the last thing we do with the data for this particular 'for' loop, we finish by popping it off the stack.
}

// Compile a `continue` in a `for loop`.
func (cp *Compiler) emitContinue(tok *token.Token, ctxt Context) cpResult {
	if len(cp.forData) == 0 {
		cp.Throw("comp/continue", tok)
		return FAIL
	}
	cp.addToForData(cp.vmContinue())
	return cpResult{Types: ctxt.ForReturns}
}

func (cp *Compiler) vmContinue() bkContinue {
	cp.Emit(vm.Jmp, DUMMY)
	return bkContinue(cp.CodeTop() - 1)
}

// Compile `break` statements.
func (cp *Compiler) vmBreakWithoutValue() bkBreakWithoutValue {
	cp.Emit(vm.Jmp, DUMMY)
	return bkBreakWithoutValue(cp.CodeTop() - 1)
}

func (cp *Compiler) vmBreakWithValue(mLoc uint32) bkBreakWithValue {
	cp.Emit(vm.Asgm, DUMMY, mLoc)
	cp.Emit(vm.Jmp, DUMMY)
	return bkBreakWithValue(cp.CodeTop() - 2)
}

func (cp *Compiler) emitBreakWithoutValue(tok *token.Token, ctxt Context) cpResult {
	if len(cp.forData) == 0 {
		cp.Throw("comp/break/b", tok)
		return FAIL
	}
	cp.addToForData(cp.vmBreakWithoutValue())
	return cpResult{Types: ctxt.ForReturns}
}

func (cp *Compiler) addToForData(x any) {
	cp.forData[len(cp.forData)-1] = append(cp.forData[len(cp.forData)-1], x)
}

func (cp *Compiler) forDataExists() bool {
	return len(cp.forData) > 0
}

// Either produces a lambda, if it has no closures, or we make a lambda factory and emit a `mkfn` instruction
// to produce a lambda from the lambda factory at runtime.
// TODO --- this is inside out, we should construct the factory if we need it rather than throwing it
// away if we don't.
func (cp *Compiler) compileLambda(env *Environment, ctxt Context, fnNode *parser.FuncExpression, tok *token.Token) bool {
	cp.Cm("Compiling lambda", tok)
	LF := &vm.LambdaFactory{Model: &vm.Lambda{}}
	newEnv := NewEnvironment()
	nameSig := fnNode.NameSig
	skipLambdaCode := cp.vmGoTo()
	LF.Model.CapturesStart = cp.MemTop()
	cp.pushLambdaStart()

	// We get the function parameters. These shadow anything we might otherwise capture.
	params := dtypes.Set[string]{}
	for _, pair := range nameSig {
		params = params.Add(pair.VarName)
		if parser.IsAnyNullableType(pair.VarType) {
			LF.Model.Sig = append(LF.Model.Sig, values.AbstractType{nil}) // 'nil' in a sig in this context means we don't need to typecheck.
		} else {
			LF.Model.Sig = append(LF.Model.Sig, cp.GetAbstractTypeFromAstType(pair.VarType))
		}
	}
	LF.Model.Tok = &fnNode.Token
	captures := parser.GetVariableNames(fnNode)
	for k := range captures {
		if params.Contains(k) {
			continue
		}
		v, ok := env.GetVar(k)
		if !ok {
			cp.Cm("Throwing unknown identifier error", tok)
			cp.Throw("comp/body/known", tok, k)
			return false
		}
		if v.Access == GLOBAL_CONSTANT_PRIVATE || v.Access == GLOBAL_CONSTANT_PUBLIC || v.Access == LOCAL_CONSTANT {
			cp.Cm("Binding name "+text.Emph(k)+" in lambda to existing constant at location m"+strconv.Itoa(int(v.MLoc))+".", fnNode.GetToken())
			newEnv.Data[k] = *v
		} else {
			cp.Reserve(values.UNDEFINED_TYPE, nil, fnNode.GetToken()) // It doesn't matter what we put in here 'cos we copy the values any time we call the LambdaFactory.
			cp.Cm("Adding variable for lambda capture.", fnNode.GetToken())
			cp.AddThatAsVariable(newEnv, k, v.Access, v.Types, fnNode.GetToken())
		}
		// At the same time, the lambda factory need to know where they are in the calling vm.Vm.
		LF.CaptureLocations = append(LF.CaptureLocations, v.MLoc)
	}
	LF.Model.CapturesEnd = cp.MemTop()

	potentialFuncs := parser.GetPrefixes(fnNode)
	for k := range potentialFuncs {
		v, ok := env.GetVar(k)
		if ok {
			cp.Cm("Binding name of function "+text.Emph(k)+" in lambda to existing constant at location m"+strconv.Itoa(int(v.MLoc))+".", fnNode.GetToken())
			newEnv.Data[k] = *v
		}
	}

	cp.StartPushMem() // !!! Anything that early-returned from this function would have to clean up the PushMem artefacts.

	cp.Cm("Adding function parameters", tok)
	// Add the function parameters.
	for _, pair := range nameSig { // It doesn't matter what we put in here either, because we're going to have to copy the values any time we call the function.
		cp.Reserve(0, DUMMY, fnNode.GetToken())
		cp.Cm("Adding parameter '"+pair.VarName+"' to lambda.", fnNode.GetToken())
		cp.AddThatAsVariable(newEnv, pair.VarName, FUNCTION_ARGUMENT, cp.GetAlternateTypeFromTypeAst(pair.VarType), fnNode.GetToken())
	}
	LF.Model.ParametersEnd = cp.MemTop()

	// Compile the locals.
	saveThunkList := cp.ThunkList
	if fnNode.Given != nil {
		cp.ThunkList = []ThunkData{}
		newContext := ctxt
		newContext.Env = newEnv
		newContext.Access = LAMBDA
		cp.CompileGivenBlock(fnNode.Given, newContext) // TODO --- must pass from outer context. TODO 2 --- what the hell did I mean by that?
	}

	// Function starts here.
	LF.Model.AddressToCall = cp.CodeTop()

	// Initialize the thunks, if any.
	if fnNode.Given != nil {
		if len(cp.ThunkList) > 0 {
			cp.Cm("Initializing thunks for lambda.", fnNode.GetToken())
		}
		for _, thunk := range cp.ThunkList {
			cp.Emit(vm.Thnk, thunk.Dest, thunk.Value.MLoc, thunk.Value.CAddr)
		}
		cp.ThunkList = saveThunkList
	}
	rTypes := fnNode.NameRets
	newRets := cp.ReturnSigToAlternateType(rTypes)
	newContext := ctxt
	newContext.Env = newEnv
	newContext.Access = LAMBDA
	newContext.Typecheck = newRets
	// Compile the main body of the lambda.
	bodyCpResult := cp.CompileNode(fnNode.Body, newContext)
	if bodyCpResult.Failed {
		return false
	}
	LF.Model.ResultLocation = cp.That()
	cp.ResolveMemPush(cp.That() - 1)
	if fnNode.NameRets != nil {
		cp.Cm("Typechecking returns from lambda.", fnNode.GetToken())
		cp.EmitTypeChecks(LF.Model.ResultLocation, bodyCpResult.Types, env, cp.AstSigToAltSig(rTypes), tok, CHECK_RETURN_TYPES)
	}
	cp.Emit(vm.Ret)
	cp.popLambdaStart()
	cp.VmComeFrom(skipLambdaCode)

	// We have made our lambda factory! But do we need it? If there are no captures, then the function is a constant, and we
	// can just reserve it in memory.

	if captures.IsEmpty() {
		cp.Cm("No captures. Emiting FUNC value.", fnNode.GetToken())
		cp.Reserve(values.FUNC, *LF.Model, fnNode.GetToken())
		return true
	}
	cp.Cm("Captures exist. Creating lambda factory.", fnNode.GetToken())
	cp.Vm.LambdaFactories = append(cp.Vm.LambdaFactories, LF)
	cp.Put(vm.Mkfn, uint32(len(cp.Vm.LambdaFactories)-1))
	return true
}

// Compiles a `given` block by calling the auxiliary function `getPartsOfGiven`, and then calling
// `compileOneGivenChunk one by one on the parts it returns.
func (cp *Compiler) CompileGivenBlock(given parser.Node, ctxt Context) bool {
	cp.Cm("Compiling 'given' block.", given.GetToken())
	nameToNode := map[string]*parser.AssignmentExpression{}
	nameGraph := dtypes.NewDigraph()
	chunks := cp.SplitOnNewlines(given)
	for _, chunk := range chunks {
		if chunk.GetToken().Type != token.GVN_ASSIGN {
			cp.Throw("comp/given/assign", chunk.GetToken())
			return false
		}
		assEx := chunk.(*parser.AssignmentExpression)
		lhsSig, ok := cp.P.ReparseSig(assEx.Left, parser.DEFAULT_TYPE_AST)
		if !ok {
			return false
		}
		rhs := parser.GetVariableNames(assEx.Right)
		for _, pair := range lhsSig {
			_, exists := ctxt.Env.GetVar(pair.VarName)
			if exists {
				cp.Throw("comp/given/exists", chunk.GetToken(), pair.VarName)
				return false
			}
			nameToNode[pair.VarName] = assEx
			if reflect.TypeOf(assEx.Right) == reflect.TypeFor[*parser.FuncExpression]() {
				if len(rhs) == 0 { // Then the lambda has no captures and so is a constant.
					cp.Cm("Reserving dummy local function "+text.Emph(pair.VarName)+".", assEx.GetToken())
					cp.Reserve(values.FUNC, nil, chunk.GetToken())
					cp.AddThatAsVariable(ctxt.Env, pair.VarName, LOCAL_FUNCTION_CONSTANT, altType(values.FUNC), assEx.GetToken())
				} else {
					cp.Cm("Reserving dummy local function thunk "+text.Emph(pair.VarName)+".", assEx.GetToken())
					cp.Reserve(values.THUNK, nil, chunk.GetToken())
					cp.AddThatAsVariable(ctxt.Env, pair.VarName, LOCAL_FUNCTION_THUNK, altType(values.FUNC), assEx.GetToken())
				}
			}
			for v := range rhs {
				dtypes.AddTransitiveArrow(nameGraph, pair.VarName, v)
			}
			if len(rhs) == 0 {
				dtypes.AddTransitiveArrow(nameGraph, pair.VarName, "")
			}
		}
	}
	order := dtypes.Tarjan(nameGraph)
	used := dtypes.Set[string]{} // If we have a multiple assignment, we only want to compile the rhs once.
	for _, partition := range order {
		if len(partition) > 1 {
			cp.Throw("comp/given/order", given.GetToken(), partition)
			return false
		}
		v := partition[0]
		node, ok := nameToNode[v]
		if ok && !used.Contains(v) {
			used.AddSet(dtypes.MakeFromSlice(cp.P.GetVariablesFromSig(node.Left)))
			if !cp.compileOneGivenChunk(node, ctxt) {
				return false
			}
		}
	}
	return true
}

// Function auxiliary to the previous one, `CompileGivenBlock`, to break down a `given` block into its
// component declarations so they can be passed one by one to the next function, `compileOneGivenBlock`.
func (cp *Compiler) SplitOnNewlines(block parser.Node) []parser.Node {
	result := []parser.Node{}
	switch branch := block.(type) {
	case *parser.LazyInfixExpression:
		if branch.Token.Literal == ";" {
			result = cp.SplitOnNewlines(branch.Left)
			rhs := cp.SplitOnNewlines(branch.Right)
			result = append(result, rhs...)
		}
	default:
		result = []parser.Node{block}
	}
	return result
}

// As it says, compiles one expression from the `given` block. Called by `CompileGivenBlock`.
func (cp *Compiler) compileOneGivenChunk(node *parser.AssignmentExpression, ctxt Context) bool {
	cp.Cm("Compiling one 'given' block assignment.", node.GetToken())
	oldThis, thisExists := ctxt.Env.GetVar("this")
	sig, ok := cp.P.ReparseSig(node.Left, parser.ANY_NULLABLE_TYPE_AST)
	if !ok {
		return false
	}
	thunkStart := cp.Next()
	result := cp.CompileNode(node.Right, ctxt.x())
	if result.Failed {
		return false
	}
	if recursivelyContains(result.Types, SimpleType(values.ERROR)) { // TODO --- this is a loathsome kludge over the fact that we're not constructing it that way in the first place.
		result.Types = result.Types.Union(altType(values.ERROR))
	}
	resultLocation := cp.That()
	if result.Types.isOnly(values.ERROR) {
		cp.Throw("comp/assign/error", node.Left.GetToken())
		return false
	}
	for i, pair := range sig {
		v, alreadyExists := ctxt.Env.GetVar(pair.VarName) // In that case we (should) have an inner function declaration and the sig will have length 1.
		// We check that it isn't just the user redefining a variable.
		if alreadyExists && pair.VarName != "_" {
			if v.Access == LOCAL_FUNCTION_THUNK && cp.Vm.Mem[v.MLoc].V == nil || v.Access == LOCAL_FUNCTION_CONSTANT && cp.Vm.Mem[v.MLoc].V == nil {
				ctxt.Env.Data["this"] = *v
			} else {
				cp.Throw("comp/given/redeclared", node.GetToken(), pair.VarName)
				return false
			}
		}
		var typeToUse AlternateType // TODO: we can extract more meaningful information about the tuple from the types.
		if t, ok := pair.VarType.(*parser.TypeWithName); ok && t.OperatorName == "tuple" {
			typeToUse = cp.Common.AnyTuple
		} else {
			typeToUse = typesAtIndex(result.Types, i)
		}
		if result.Foldable { // TODO --- we should implement constant folding of course, but there's no big hurry because hardly enyone will declare constant here, why would they?
			if !result.Types.containsAnyOf(cp.Common.CodeGeneratingTypes.ToSlice()...) {
				cp.Cm("Adding foldable constant from compileOneGivenChunk.", node.GetToken())
				cp.AddThatAsVariable(ctxt.Env, pair.VarName, LOCAL_CONSTANT, typeToUse, node.GetToken())
				continue
			} else {
				cp.Cm("Adding unfoldable constant from compileOneGivenChunk.", node.GetToken())
				cp.AddThatAsVariable(ctxt.Env, pair.VarName, LOCAL_CONSTANT, typeToUse, node.GetToken())
			}
		} else {
			if alreadyExists {
				switch { // The case where neither of these is true has been checked for above.
				case v.Access == LOCAL_FUNCTION_THUNK:
					cp.Cm("Reassigning local function thunk "+text.Emph(pair.VarName)+" from dummy value.", node.GetToken())
					cp.Vm.Mem[v.MLoc] = val(values.THUNK, values.ThunkValue{cp.That(), thunkStart})
					cp.ThunkList = append(cp.ThunkList, ThunkData{v.MLoc, values.ThunkValue{cp.That(), thunkStart}})
				case v.Access == LOCAL_FUNCTION_CONSTANT:
					cp.Cm("Reassigning local function constant "+text.Emph(pair.VarName)+" from dummy value in compileOneGivenChunk.", node.GetToken())
					cp.Vm.Mem[v.MLoc] = cp.Vm.Mem[cp.That()]
				}
			} else {
				cp.Cm("Reserving local thunk in compileOneGivenChunk.", node.GetToken())
				cp.Reserve(values.THUNK, values.ThunkValue{cp.That(), thunkStart}, node.GetToken())
				cp.AddThatAsVariable(ctxt.Env, pair.VarName, LOCAL_VARIABLE_THUNK, typeToUse, node.GetToken())
				cp.ThunkList = append(cp.ThunkList, ThunkData{cp.That(), values.ThunkValue{cp.That(), thunkStart}})
			}
		}
	}
	// NOTE --- we perform this check here rather than at the start of the method because
	// we want the variables to be declared, otherwise this will cause an error storm when
	// trying to compile the main body.
	cp.Cm("Typechecking and inserting result into local variables.", node.GetToken())
	cp.EmitTypeChecks(resultLocation, result.Types, ctxt.Env, cp.AstSigToAltSig(sig), node.GetToken(), CHECK_GIVEN_ASSIGNMENTS)
	if thisExists {
		ctxt.Env.Data["this"] = *oldThis
	} else {
		delete(ctxt.Env.Data, "this")
	}
	cp.Emit(vm.Ret)
	return true
}

// Auxiliary functions for keeping track of compiling lambdas.
func (cp *Compiler) pushLambdaStart() {
	cp.lambdaMemStarts = append(cp.lambdaMemStarts, cp.MemTop())
}
func (cp *Compiler) popLambdaStart() {
	cp.lambdaMemStarts = cp.lambdaMemStarts[:len(cp.lambdaMemStarts)-1]
}
func (cp *Compiler) getLambdaStart() uint32 {
	return cp.lambdaMemStarts[len(cp.lambdaMemStarts)-1]
}

// A function for making snippet factories.
func (cp *Compiler) reserveSnippetFactory(env *Environment, node *parser.SnippetLiteral, ctxt Context) uint32 {
	cp.Cm("Reserving snippet factory.", &node.Token)
	snF := &vm.SnippetFactory{}
	snF.Bindle = cp.compileSnippet(node.GetToken(), env, node.Values, ctxt)
	if snF.Bindle == nil {
		return DUMMY
	}
	cp.Vm.SnippetFactories = append(cp.Vm.SnippetFactories, snF)
	return uint32(len(cp.Vm.SnippetFactories) - 1)
}

// Reserves information to be emitted when a typecheck fails at runtime.
// TODO --- move to intializer.
func (cp *Compiler) ReserveTypeCheckError(node parser.Node, typename string, valLoc uint32) uint32 {
	cp.Cm("Reserving typeCheckError factory.", node.GetToken())
	err := &vm.TypeCheckError{Tok: node.GetToken(), Condition: cp.P.PrettyPrint(node),
		Type: typename, Value: valLoc}
	cp.Vm.TypeCheckErrors = append(cp.Vm.TypeCheckErrors, err)
	return uint32(len(cp.Vm.TypeCheckErrors) - 1)
}

// Compiles a test for equality.
func (cp *Compiler) compileEquals(node *parser.ComparisonExpression, ctxt Context) cpResult {
	lResult := cp.CompileNode(node.Left, ctxt.x())
	if lResult.Types.isOnly(values.ERROR) {
		cp.Throw("comp/error/eq/a", node.GetToken())
		return FAIL
	}
	if lResult.Failed {
		return FAIL
	}
	leftRg := cp.That()
	rResult := cp.CompileNode(node.Right, ctxt.x())
	if rResult.Types.isOnly(values.ERROR) {
		cp.Throw("comp/error/eq/b", node.GetToken())
		return FAIL
	}
	if rResult.Failed {
		return FAIL
	}
	rightRg := cp.That()
	oL := lResult.Types.intersect(rResult.Types)
	if oL.isOnly(values.ERROR) {
		cp.Throw("comp/error/eq/c", node.GetToken())
		return FAIL
	}
	if len(oL) == 0 {
		cp.Throw("comp/eq/types", node.GetToken(), lResult.Types.describe(cp.Vm), rResult.Types.describe(cp.Vm))
		return FAIL
	}
	if len(oL) == 1 && len(lResult.Types) == 1 && len(rResult.Types) == 1 {
		switch el := oL[0].(type) { // TODO --- we can do as much of this stuff as actually makes things performant before handing it over to Eqxx
		case SimpleType:
			switch el {
			case tp(values.INT):
				cp.Put(vm.Equi, leftRg, rightRg)
				return concResult(values.BOOL, lResult.Foldable && rResult.Foldable)
			case tp(values.STRING):
				cp.Put(vm.Equs, leftRg, rightRg)
				return concResult(values.BOOL, lResult.Foldable && rResult.Foldable)
			case tp(values.BOOL):
				cp.Put(vm.Equb, leftRg, rightRg)
				return concResult(values.BOOL, lResult.Foldable && rResult.Foldable)
			case tp(values.FLOAT):
				cp.Put(vm.Equf, leftRg, rightRg)
				return concResult(values.BOOL, lResult.Foldable && rResult.Foldable)
			case tp(values.TYPE):
				cp.Put(vm.Equt, leftRg, rightRg)
				return concResult(values.BOOL, lResult.Foldable && rResult.Foldable)
			}
		}
	}
	cp.Put(vm.Eqxx, leftRg, rightRg, cp.ReserveToken(node.GetToken()))
	return cpResult{Types: AltType(values.ERROR, values.BOOL), Foldable: lResult.Foldable && rResult.Foldable}
}

// Compiles a logging expression.
func (cp *Compiler) compileLog(node *parser.LogExpression, ctxt Context) (uint32, bool, bool) {
	output := cp.Reserve(values.STRING, "", &node.Token)
	first := true
	logStr := node.Value
	strList, ok := text.GetTextWithBarsAsList(logStr)
	if !ok {
		cp.Throw("comp/log/close", &node.Token)
		return uint32(DUMMY), false, false
	}
	// So at this point we have a strList consisting of things which either do or don't need parsing and compiling,
	// depending on whether they are or aren't bracketed by | symbols.
	// If they don't need compiling they can just be concatenated to the output.
	errorReturns := []BkEarlyReturn{}
	for _, str := range strList {
		if str == "" {
			continue
		}
		if str[0] == '|' { // Then we must parse and compile.
			parsedAst := cp.P.ParseLine("code snippet in log expression", str[1:len(str)-1])
			sResult := cp.CompileNode(parsedAst, ctxt.x())
			if sResult.Failed {
				return uint32(DUMMY), false, false
			}
			thingToAdd := cp.That()
			if sResult.Types.Contains(values.ERROR) {
				errorReturns = append(errorReturns,
					cp.VmConditionalEarlyReturn(vm.Qtyp, cp.That(), uint32(values.ERROR), cp.That()))
			}
			cp.Put(vm.Strx, thingToAdd)
		} else { // Otherwise, we just add it on as a string.
			cp.Reserve(values.STRING, str, node.GetToken())
		}
		if first {
			cp.Emit(vm.Asgm, output, cp.That())
			first = false
		} else {
			cp.Emit(vm.Adds, output, output, cp.That())
		}
	}
	for _, rtn := range errorReturns {
		cp.VmComeFrom(rtn)
	}
	return output, len(errorReturns) > 0, true
}

// The various 'piping operators'.
func (cp *Compiler) compilePipe(lhsTypes AlternateType, lhsConst bool, rhs parser.Node, env *Environment, ctxt Context) cpResult {
	var envWithThat *Environment
	// If we have an identifier `foo`, we desugar it into `foo(that)`.
	rhs = desugar(rhs)
	var whatAccess VarAccess // TODO --- why?
	if lhsConst {
		whatAccess = VERY_LOCAL_CONSTANT
	} else {
		whatAccess = VERY_LOCAL_VARIABLE
	}
	envWithThat = &Environment{Data: map[string]Variable{"that": {MLoc: cp.That(), Access: whatAccess, Types: lhsTypes}}, Ext: env}
	newContext := ctxt
	newContext.Env = envWithThat
	return cp.CompileNode(rhs, newContext)
}

func (cp *Compiler) compileMappingOrFilter(lhsTypes AlternateType, lhsConst bool, rhs parser.Node, env *Environment, ctxt Context, isFilter bool) cpResult {
	tok := rhs.GetToken()
	if isFilter {
		cp.Cm("Compiling filter.", tok)
	} else {
		cp.Cm("Compiling mapping.", tok)
	}
	cp.Cm("rhs is "+text.Emph(rhs.String()), tok)
	cp.Cm("lhsTypes is "+text.Emph(lhsTypes.describe(cp.Vm)), tok)
	inputElement := uint32(DUMMY)
	typeIsNotFunc := BkEarlyReturn(DUMMY)
	resultIsError := BkEarlyReturn(DUMMY)
	resultIsNotBool := BkEarlyReturn(DUMMY)
	lhsIsNotListlike := BkEarlyReturn(DUMMY)
	var types AlternateType
	sourceList := cp.That()
	envWithThat := &Environment{}
	thatLoc := uint32(DUMMY)
	overlap := lhsTypes.intersect(cp.Common.SharedTypenameToTypeList["clones{list}"])
	if len(overlap) == 0 {
		cp.Throw("comp/pipe/mf/list", rhs.GetToken())
		return FAIL
	}
	if len(overlap) < len(lhsTypes) {
		err := cp.ReserveError("vm/mf/lhs", rhs.GetToken())
		if len(overlap) == 1 {
			lhsIsNotListlike = cp.VmConditionalEarlyReturn(vm.Qntp, sourceList, uint32(overlap[0].(SimpleType)), err)
		} else {
			args := []uint32{sourceList}
			for _, t := range overlap {
				args = append(args, uint32(t.(SimpleType)))
			}
			args = append(args, err)
			lhsIsNotListlike = cp.VmConditionalEarlyReturn(vm.Qnab, args...)
		}
	}
	rhs = desugar(rhs)
	thatLoc = cp.Reserve(values.UNDEFINED_TYPE, DUMMY, rhs.GetToken())
	envWithThat = &Environment{Data: map[string]Variable{"that": {MLoc: cp.That(), Access: VERY_LOCAL_VARIABLE, Types: cp.GetAlternateTypeFromTypeAst(parser.ANY_NULLABLE_TYPE_AST)}}, Ext: env}
	cp.Put(vm.Asgm, values.C_ZERO)
	counter := cp.That()
	cp.Put(vm.Asgm, values.C_EMPTY_TUPLE)
	accumulator := cp.That()
	cp.Put(vm.LenL, sourceList)
	length := cp.That()
	cp.Cm("Start of loop.", tok)
	loopStart := cp.CodeTop()
	cp.Cm("Check if the list is finished.", tok)
	cp.Put(vm.Gthi, length, counter)
	listFinished := cp.vmIf(vm.Qtru, cp.That())
	cp.Cm("Emit the body of the loop.", tok)
	cp.Emit(vm.IdxL, thatLoc, sourceList, counter, DUMMY)
	inputElement = thatLoc
	newContext := ctxt
	newContext.Env = envWithThat
	result := cp.CompileNode(rhs, newContext)
	if result.Failed {
		return FAIL
	}
	resultElement := cp.That()
	if result.Types.Contains(values.ERROR) {
		cp.Cm("If the result of the function's 'that' expression might be an error, we test for that and early-return the error if so.", tok)
		cp.Emit(vm.Qtyp, resultElement, uint32(values.ERROR), cp.CodeTop()+3)
		resultIsError = cp.vmEarlyReturn(cp.That())
	}
	if isFilter {
		if !result.Types.Contains(values.BOOL) {
			cp.Throw("comp/pipe/filter/bool", rhs.GetToken())
		}
		if !result.Types.isOnly(values.BOOL) {
			cp.Cm("The function we're filtering on might return something other than a boolean so we emit a check.", tok)
			cp.ReserveError("vm/pipe/filter/bool", rhs.GetToken())
			cp.Emit(vm.Qntp, resultElement, uint32(values.BOOL), cp.CodeTop()+3)
			resultIsNotBool = cp.vmEarlyReturn(cp.That())
		}
		cp.Cm("We see if the result of the filter function is true and if so, we add it to the accumulator tuple.", tok)
		cp.Emit(vm.Qtru, resultElement, cp.CodeTop()+2)
		cp.Emit(vm.CcT1, accumulator, accumulator, inputElement)
	} else { // It's a map.
		cp.Cm("We add the result of the mapping function to the accumulator tuple.", tok)
		cp.Emit(vm.CcT1, accumulator, accumulator, resultElement)
	}
	cp.Cm("We increment the counter and jump to the top of the loop.", tok) // TODO --- don't we have an increment opcode? Shouldn't we make one?
	cp.Emit(vm.Addi, counter, counter, values.C_ONE)
	cp.Emit(vm.Jmp, loopStart)
	cp.VmComeFrom(listFinished)
	cp.Cm("We turn the accumulator tuple into a list and leave the result on top of memory.", tok)
	cp.Put(vm.List, accumulator)
	cp.VmComeFrom(typeIsNotFunc, resultIsError, resultIsNotBool, lhsIsNotListlike)
	cp.Cm("We've finished compiling the mapping/filter operator.", tok)

	if types.Contains(values.ERROR) {
		return cpResult{Types: AltType(values.ERROR, values.LIST), Foldable: lhsConst && result.Foldable}
	}
	return concResult(values.LIST, lhsConst && result.Foldable)
}

// This supports the piping functions by desugaring things of the form `foo`
// into `foo(that)`
func desugar(node parser.Node) parser.Node {
	if ident, ok := node.(*parser.Identifier); ok && !(ident.Value == "that") {
		thatIdent := &parser.Identifier{token.Token{}, "that"}
		prefix := &parser.PrefixExpression{ident.Token, ident.Value, []parser.Node{thatIdent}}
		return prefix
	}
	return node
}

func (cp *Compiler) compileSnippet(tok *token.Token, newEnv *Environment, nodes []parser.Node, ctxt Context) *values.SnippetBindle {
	cp.Cm("Compile snippet", tok)
	bindle := values.SnippetBindle{}
	bindle.CodeLoc = cp.CodeTop()
	for i, node := range nodes {
		if i%2 == 1 {
			newContext := ctxt
			newContext.Env = newEnv
			cResult := cp.CompileNode(node, newContext)
			if cResult.Failed {
				return nil
			}
			val := cp.That()
			if cResult.Types.Contains(values.TUPLE) {
				cp.Throw("comp/snippet/tuple", tok)
				return nil
			}
			bindle.ValueLocs = append(bindle.ValueLocs, val)
		} else {
			cp.Reserve(values.STRING, node.(*parser.StringLiteral).Value, tok)
			bindle.ValueLocs = append(bindle.ValueLocs, cp.That())
		}
	}
	return &bindle
}

// To keep the following function from being many functions, we're going to pass it a thing modifying its behavior. Which, yeah,
// has its own problems. I should have written a Lisp in Lisp, I'd have been finished in half-an-hour.
type typeCheckFlavor int

// Some of these are not switched on and are just meaningful ways of saying
// "none of the above".
//
// Typechecking of the parameters of top-level functions is done in the
// multiple dispatch, of course, so it doesn't get an entry.
const (
	CHECK_RETURN_TYPES typeCheckFlavor = iota
	CHECK_GIVEN_ASSIGNMENTS
	CHECK_LOOP_VARIABLE_ASSIGNMENTS
	CHECK_LAMBDA_PARAMETERS
	CHECK_LOCAL_CMD_ASSIGNMENTS // Note that in the case of multiple assignment, just one global
	CHECK_GLOBAL_ASSIGNMENTS    // variable on the left makes it global.
)

// We take (a location of) a single value or tuple, the type as an AlternateType, a signature, an environment, a token, and a
// 'flavor' which says what exactly we're doing and in particular whether the sig contains names we should be inserting the tuple
// elements into or is just a return type signature in which case there will be no names and we can leave them as they are.
// We generate code which emits as much type-checking as is necessary given the fit of the signature to the AlternateType,
// and which inserts the values of the tuple into the variables specified in the signature.
// If the types cannot fit the sig we should of course emit a compile-time error. If they *may* not fit the sig, the runtime
// equivalent is to fill the parameters up with an error value generated from the token.
// If the sig is of an assignment in a command or a given block, then this is in fact all that needs to be done. If it's a
// lambda, then the rest of the code in the lambda can then return an error if passed one.
func (cp *Compiler) EmitTypeChecks(
		loc uint32, // The address of the thing to be typechecked, which may be a tuple.
	    types AlternateType, // The type it needs to match.
		env *Environment, // The environment of the `residualSig` (below).
		sig alternateSig, // The sig to insert values into.
		tok *token.Token, // A token for emitting errors with.
		flavor typeCheckFlavor, // Says exactly what sort of thing we're tyechecking.
	) BkEarlyReturn {
	cp.CmR("Emitting type checks.", tok)
	cp.Cm("Sig is "+sig.Describe(cp.Vm)+".", tok)
	if len(sig) == 0 { // We have a function without specified return types
		return BkEarlyReturn(DUMMY)
	}
	// The insert variable says whether we're just doing a typecheck against the sig or whether we're inserting values into variables.
	insert := (flavor != CHECK_RETURN_TYPES)
	// The earlyReturnOnFailure variable does what it sounds like. In the case when we are typechecking the arguments of a lambda or an assignment involving a global
	// variable, we have to be able to early-return the error.
	earlyReturnOnFailure := (flavor == CHECK_GLOBAL_ASSIGNMENTS || flavor == CHECK_LAMBDA_PARAMETERS || flavor == CHECK_LOOP_VARIABLE_ASSIGNMENTS)
	// And so this is the early return address that we're going to return to the caller if necessary, which can discharge it with a ComeFrom.
	errorCheck := BkEarlyReturn(DUMMY)
	errorCode := ""
	switch flavor {
	case CHECK_LAMBDA_PARAMETERS:
		errorCode = "vm/typecheck"
	case CHECK_RETURN_TYPES:
		errorCode = "vm/typecheck/return"
	default:
		errorCode = "vm/typecheck/assign"
	}
	errorLocation := cp.ReserveError(errorCode, tok)
	lengthCheck := bkIf(DUMMY)
	inputIsError := bkGoto(DUMMY)
	jumpFromSingleCheckToEnd := bkGoto(DUMMY)
	jumpFromTupleCheckToEnd := bkGoto(DUMMY)
	typeChecks := []bkGoto{}
	singles, tuples := types.splitSinglesAndTuples()
	lastIsTuple := len(sig) > 0 && sig[len(sig)-1].VarType.containsOnlyTuples()
	if types.isOnly(values.ERROR) {
		cp.Throw("comp/typecheck/error", tok)
		return errorCheck
	}
	if types.Contains(values.ERROR) {
		cp.Cm("Checking for errror.", tok)
		cp.Emit(vm.Qtyp, loc, uint32(values.ERROR), cp.CodeTop()+3)
		cp.Emit(vm.Asgm, errorLocation, loc)
		inputIsError = cp.vmGoTo()
	}
	if len(singles) == 0 && len(sig) == 1 {
		cp.Throw("comp/typecheck/values/a", tok)
		return errorCheck
	}
	if len(tuples) == 0 && len(sig) != 1 {
		cp.Throw("comp/typecheck/values/b", tok)
		return errorCheck
	}
	if insert {
		cp.Cm("Inserting into variable", tok)
		vData, _ := env.GetVar(sig[0].VarName) // It is assumed that we've already made it exist.
		if vData.Access == REFERENCE_VARIABLE {
			if lastIsTuple {
				cp.Put(vm.Cv1T, loc)
				cp.Emit(vm.Aref, vData.MLoc, cp.That())
			} else {
				cp.Emit(vm.Aref, vData.MLoc, loc)
			}
		} else {
			if lastIsTuple {
				cp.Emit(vm.Cv1T, vData.MLoc, loc)
			} else {
				cp.Emit(vm.Asgm, vData.MLoc, loc)
			}
		}
	}
	isTuple := bkIf(DUMMY)
	if len(tuples) == 0 {
		// We would by this point have thrown an error if the sig length wasn't 1, so we can just
		// do the typecheck.
		sigTypes := sig[0].VarType
		overlap := singles.intersect(sigTypes)
		if len(overlap) == 0 || overlap.isOnly(values.ERROR) {
			cp.Throw("comp/typecheck/type", tok)
			return errorCheck
		}
		if len(overlap) != len(singles) {
			cp.Cm("No tuples, sig has length 1, emitting typecheck", tok)
			// If the condition is not met, this jumps to where we `ComeFrom` the elements of `typechecks`.
			typeCheck := cp.emitTypeComparisonFromAltType(sig[0].VarType, loc, tok)
			typeChecks = append(typeChecks, typeCheck)
		}
		if insert {
			vr, _ := env.GetVar(sig[0].VarName)
			if vr.Access == REFERENCE_VARIABLE {
				cp.Emit(vm.Aref, vr.MLoc, loc)
			} else {
				cp.Emit(vm.Asgm, vr.MLoc, loc)
			}
		}
		jumpFromSingleCheckToEnd = cp.vmGoTo()
	} else {
		cp.Cm("Checking for tuple", tok)
		isTuple = cp.vmIf(vm.Qtyp, loc, uint32(values.TUPLE))
		lengths := lengths(tuples)
		goodLengths := 0
		badLengths := 0
		for ln := range lengths {
			if ln == -1 { // If the tuple can be any length then this is good only if the 0dx type of the sig is a tuple.
				if lastIsTuple && len(sig) == 1 {
					goodLengths++
				}
				continue
			}
			if ln == len(sig) || lastIsTuple && ln >= len(sig)-1 {
				goodLengths++
			} else {
				badLengths++
			}
		}
		if badLengths == len(lengths) {
			cp.Throw("comp/typecheck/values/b", tok)
			return errorCheck
		}

		if goodLengths != len(lengths) {
			cp.Cm("Checking tuple lengths", tok)
			if lastIsTuple {
				lengthCheck = cp.vmIf(vm.QlnT, loc, uint32(len(lengths)))
			} else {
				lengthCheck = cp.vmIf(vm.QleT, loc, uint32(len(lengths)))
			}
		}
		if lastIsTuple {
			vr, _ := env.GetVar(sig[len(sig) - 1].VarName)
			cp.Emit(vm.SlTn, vr.MLoc, loc, uint32(len(sig)-1)) // Gets the end of the slice. We can put anything in a tuple.
		}
		elementLoc := uint32(DUMMY)
		// Now let's typecheck the other things.
		for i := 0; i < len(sig); i++ {
			typesToCheck := typesAtIndex(types, i)
			sigTypes := sig[i].VarType
			overlap := typesToCheck.intersect(sigTypes)
			if len(overlap) == 0 || overlap.isOnly(values.ERROR) {
				cp.Throw("comp/typecheck/type", tok)
				return errorCheck
			}
			if len(overlap) == len(typesToCheck) {
				continue
			}
			if elementLoc == DUMMY {
				elementLoc = cp.Reserve(values.UNDEFINED_TYPE, nil, tok)
			}
			cp.Emit(vm.IxTn, elementLoc, loc, uint32(i))
			cp.Cm("Emitting type check for " + sig[i].VarType.describe(cp.Vm), tok)
			typeCheck := cp.emitTypeComparisonFromAltType(sig[i].VarType, elementLoc, tok)
			typeChecks = append(typeChecks, typeCheck)
		}
		// If we're inserting the values from a tuple into the variables, this is where we do it.
		if insert {
			for i := 0; i < len(sig); i++ {
				vr, _ := env.GetVar(sig[i].VarName)
				if vr.Access == REFERENCE_VARIABLE {
					cp.Put(vm.IxTn, loc, uint32(i))
					cp.Emit(vm.Aref, vr.MLoc, cp.That())
				} else {
					cp.Emit(vm.IxTn, vr.MLoc, loc, uint32(i))
				}
			}
		}
		jumpFromTupleCheckToEnd = cp.vmGoTo()
	}

	cp.VmComeFrom(lengthCheck, inputIsError) // This is where we jump to if we fail any of the runtime tests.
	for _, tc := range typeChecks {
		cp.VmComeFrom(tc)
	}
	switch {
	case earlyReturnOnFailure:
		cp.Cm("Making early return on failure", tok)
		// This is what we're going to return from the function; it can then be used by the caller to make
		// an early return from a function or for loop.
		errorCheck = cp.vmEarlyReturn(errorLocation)
	case flavor == CHECK_LOCAL_CMD_ASSIGNMENTS || flavor == CHECK_GIVEN_ASSIGNMENTS:
		for i := 0; i < len(sig); i++ {
			vr, ok := env.GetVar(sig[i].VarName)
			if !ok {
				cp.Throw("comp/typecheck/var", tok, sig[i].VarName)
				return BkEarlyReturn(DUMMY)
			}
			cp.Emit(vm.Asgm, vr.MLoc, errorLocation)
		}
	default:
		cp.Emit(vm.Asgm, loc, errorLocation)
	}
	cp.VmComeFrom(jumpFromSingleCheckToEnd, jumpFromTupleCheckToEnd, isTuple)
	return errorCheck
}

// Adds a variable to a given environment.
func (cp *Compiler) AddThatAsVariable(env *Environment, name string, acc VarAccess, types AlternateType, tok *token.Token) {
	cp.Cm("Adding variable name "+text.Emph(name)+" bound to memory location m"+strconv.Itoa(int(cp.That()))+" with type "+types.describe(cp.Vm), tok)
	env.Data[name] = Variable{MLoc: cp.That(), Access: acc, Types: types}
}

// A couple of types to support thunking.
//
// This contains what the compiler needs to emit the 'thnk' operations at the start of a function.
type ThunkData struct {
	Dest  uint32
	Value values.ThunkValue
}

type BkRecursion struct{ FunctionNumber, Address uint32 }

// The compiler's representation of a function after the function has been compiled.
type CpFunc struct {
	CallTo                  uint32
	LoReg                   uint32
	HiReg                   uint32
	OutReg                  uint32
	LocOfTupleAndVarargData uint32
	RtnTypes                AlternateType
	Builtin                 string   // The name of a builtin or constructor, or an empty string if it's neither.
	Xcall                   *XBindle // Information for making an external call, if non-nil.
	Private                 bool     // True if it's private.
	Command                 bool     // True if it's a command.
	GoNumber                uint32
	HasGo                   bool
}

// Information we need in the CpFunc struct to call an external service.
type XBindle struct {
	ExternalServiceOrdinal uint32
	FunctionName           string
	Position               uint32
}

type alternateSig []NameAlternateTypePair

// The maximum value of a `uint32`. Used as a dummy/sentinel value when `0` is not appropriate.
const DUMMY = 4294967295

// Housekeeping functions for keeping track of the `resolving compilers`, i.e. which one is suitable
// for the namespace we find ourselves in.
func (p *Compiler) pushRCompiler(q *Compiler) {
	p.labelResolvingCompilers = append(p.labelResolvingCompilers, q)
}
func (p *Compiler) topRCompiler() *Compiler {
	return p.labelResolvingCompilers[len(p.labelResolvingCompilers)-1]
}
func (p *Compiler) popRCompiler() {
	p.labelResolvingCompilers = p.labelResolvingCompilers[1:]
}

// Types and functions for "backtracking". When we need to emit an opcode with operands we don't know yet (e.g.
// if they involve jumping over a block of code we haven't emitted yet) we stash some backtracking information
// on a stack or list or whatever and then resolve it when we have the requisite information.

type bkIf int

func (cp *Compiler) vmIf(oc vm.Opcode, args ...uint32) bkIf {
	cp.Emit(oc, (append(args, DUMMY))...)
	return bkIf(cp.CodeTop() - 1)
}

type bkGoto int

type bkContinue int

type bkBreakWithValue int

type bkBreakWithoutValue int

func (cp *Compiler) vmGoTo() bkGoto {
	cp.Emit(vm.Jmp, DUMMY)
	return bkGoto(cp.CodeTop() - 1)
}

type BkEarlyReturn int

func (cp *Compiler) vmEarlyReturn(mLoc uint32) BkEarlyReturn {
	cp.Emit(vm.Asgm, DUMMY, mLoc)
	cp.Emit(vm.Jmp, DUMMY)
	return BkEarlyReturn(cp.CodeTop() - 2)
}

func (cp *Compiler) VmConditionalEarlyReturn(oc vm.Opcode, args ...uint32) BkEarlyReturn {
	mLoc := args[len(args)-1]
	cp.Emit(oc, append(args[:len(args)-1], cp.CodeTop()+3)...)
	return cp.vmEarlyReturn(mLoc)
}

type bkMemPush int // When we make a recursive call, we don't know how much memory we'll have to stash.

func (cp *Compiler) ResolveMemPush(top uint32) {
	bks := cp.memPushData[len(cp.memPushData)-1]
	for _, bk := range bks {
		if cp.Vm.Code[bk].Opcode != vm.Rpsh {
			panic("Oops.")
		}
		cp.Vm.Code[bk].Args[1] = top
	}
	cp.memPushData = cp.memPushData[:len(cp.memPushData)-1]
}

func (cp *Compiler) StartPushMem() {
	cp.memPushData = append(cp.memPushData, []bkMemPush{})
}

func (cp *Compiler) PushMem(addr uint32) {
	// Temporarily disabled while I make compilation deterministic.
	// cp.memPushData[len(cp.memPushData)-1] = append(cp.memPushData[len(cp.memPushData)-1], bkMemPush(addr))
}

// The `VmComeFrom` function knows how to resolve the various bits of backtracking data.
func (cp *Compiler) VmComeFrom(items ...any) {
	for _, item := range items {
		switch item := item.(type) {
		case bkBreakWithValue:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].Args[0] = cp.That()
			cp.Vm.Code[uint32(item)+1].MakeLastArg(cp.CodeTop())
		case bkBreakWithoutValue:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkContinue:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkGoto:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case bkIf:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].MakeLastArg(cp.CodeTop())
		case BkEarlyReturn:
			if uint32(item) == DUMMY {
				continue
			}
			cp.Vm.Code[uint32(item)].Args[0] = cp.That()
			cp.Vm.Code[uint32(item)+1].MakeLastArg(cp.CodeTop())
		default:
			panic("Can't ComeFrom that!")
		}
	}
}

// Functions for the compiler to inspect and write to the VM.

// We have two different ways of emiting an opcode: 'Emit' does it the regular way, 'put' ensures that
// the destination is the next free memory address.
func (cp *Compiler) Emit(opcode vm.Opcode, args ...uint32) {
	cp.Vm.Code = append(cp.Vm.Code, vm.MakeOp(opcode, args...))
	if cp.showCompile {
		description := cp.Vm.DescribeCode(cp.CodeTop() - 1)
		if !testing.Testing() {
			println(description)
		}
	}
}

func (cp *Compiler) Put(opcode vm.Opcode, args ...uint32) {
	args = append([]uint32{cp.MemTop()}, args...)
	cp.Emit(opcode, args...)
	cp.Vm.Mem = append(cp.Vm.Mem, values.Value{})
}

func (cp *Compiler) emitCallOpcode(funcNumber uint32, valLocs []uint32) {
	if funcNumber >= uint32(len(cp.Fns)) {
		args := append([]uint32{DUMMY, DUMMY, DUMMY}, valLocs...)
		cp.Emit(vm.Call, args...) // TODO --- find out from the sig whether this should be CalT.
		return
	}
	args := append([]uint32{cp.Fns[funcNumber].CallTo, cp.Fns[funcNumber].LoReg, cp.Fns[funcNumber].HiReg}, valLocs...)
	if cp.Fns[funcNumber].LocOfTupleAndVarargData == DUMMY { // We specialize on whether we have to capture tuples or varargs.
		cp.Emit(vm.Call, args...)
	} else {
		cp.Emit(vm.CalT, args...) // As the data about tuples and varargs must have been stored in cp.Fns[funcNumber].HiReg if it exists, we don't need to supply anything mre in the opcode.
	}
}

func (cp *Compiler) Reserve(t values.ValueType, v any, tok *token.Token) uint32 {
	if t < values.ValueType(len(cp.Vm.ConcreteTypeInfo)) {
		cp.Cm("Reserving m"+strconv.Itoa(len(cp.Vm.Mem))+" with initial type "+cp.Vm.DescribeType(t, vm.LITERAL, 0)+".", tok) // E.g. the members of enums get created before their type. TODO --- is there a reason for this?
	} else {
		cp.Cm("Reserving m"+strconv.Itoa(len(cp.Vm.Mem))+" for initial type not yet named.", tok)
	}
	cp.Vm.Mem = append(cp.Vm.Mem, val(t, v))
	return uint32(len(cp.Vm.Mem) - 1)
}

func (cp *Compiler) ReserveError(ec string, tok *token.Token, args ...any) uint32 {
	cp.Vm.Mem = append(cp.Vm.Mem, val(values.ERROR, &err.Error{ErrorId: ec, Token: tok, Args: args, Trace: make([]*token.Token, 0, 10)}))
	cp.Cm("Reserving error '"+ec+"' at m"+strconv.Itoa(int(cp.That()))+".", tok)
	return cp.That()
}

func (cp *Compiler) ReserveToken(tok *token.Token) uint32 {
	cp.Vm.Tokens = append(cp.Vm.Tokens, tok)
	return cp.ThatToken()
}

func (cp *Compiler) MemTop() uint32 {
	return uint32(len(cp.Vm.Mem))
}

func (cp *Compiler) That() uint32 {
	return uint32(len(cp.Vm.Mem) - 1)
}

func (cp *Compiler) ThatToken() uint32 {
	return uint32(len(cp.Vm.Tokens) - 1)
}

func (cp *Compiler) CodeTop() uint32 {
	return uint32(len(cp.Vm.Code))
}

func (cp *Compiler) TokenTop() uint32 {
	return uint32(len(cp.Vm.Tokens))
}

func (cp *Compiler) LfTop() uint32 {
	return uint32(len(cp.Vm.LambdaFactories))
}

func (cp *Compiler) Next() uint32 {
	return uint32(len(cp.Vm.Code))
}

// This contains a snapshot of how much code, memory locations, etc, have been added to the respective lists at a given
// point. Then to roll back the vm, we can call the rollback function (below) on the state returned by getState.
type vmState struct {
	mem              int
	Code             int
	tokens           int
	lambdaFactories  int
	snippetFactories int
}

// This captures the record.
func (cp *Compiler) GetState() vmState {
	return vmState{len(cp.Vm.Mem), len(cp.Vm.Code), len(cp.Vm.Tokens), len(cp.Vm.LambdaFactories), len(cp.Vm.SnippetFactories)}
}

// And this rolls back the machine.
func (cp *Compiler) Rollback(vms vmState, tok *token.Token) {
	cp.Cm("Rolling back to address "+strconv.Itoa(vms.Code)+" and location "+strconv.Itoa(vms.mem)+".", tok)
	cp.Vm.Code = cp.Vm.Code[:vms.Code]
	cp.Vm.Mem = cp.Vm.Mem[:vms.mem]
	cp.Vm.Tokens = cp.Vm.Tokens[:vms.tokens]
	cp.Vm.LambdaFactories = cp.Vm.LambdaFactories[:vms.lambdaFactories]
	cp.Vm.SnippetFactories = cp.Vm.SnippetFactories[:vms.snippetFactories]
}

// For calling `init` or `main`.
func (cp *Compiler) CallIfExists(name string) (values.Value, error) {
	tree, ok := cp.FunctionForest[name]
	if !ok {
		return values.UNDEF, errors.New("`" + name + "` command does not exist.")
	}
	for _, t := range tree.Tree.Branch {
		if t.Type.Len() == 0 && t.Node.CallInfo != nil {
			fn := cp.Fns[t.Node.CallInfo.Number]
			if !fn.Command {
				return values.UNDEF, errors.New("`" + name + "` is defined as a function, not a command.")
			}
			cp.Vm.Run(cp.Fns[t.Node.CallInfo.Number].CallTo)
			return cp.Vm.Mem[cp.Fns[t.Node.CallInfo.Number].OutReg], nil
		}
	}
	return values.UNDEF, errors.New("`" + name + "` is defined with parameters.")
}

// Functions for emitting comments on what the compiler is doing, if the option to do so in the `settings.go`
// file is set to `true`.

// The regular version, in cyan.
func (cp *Compiler) Cm(comment string, tok *token.Token) {
	if settings.SHOW_COMPILER_COMMENTS && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(tok.Source)) {
		println(text.CYAN + "// " + comment + text.RESET)
	}
}

// The same as the previous method but in purple. Used to comment on the resolution of the multiple dispatch in particular.
func (cp *Compiler) cmP(comment string, tok *token.Token) {
	if settings.SHOW_COMPILER_COMMENTS && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(tok.Source)) {
		println(text.PURPLE + "// " + comment + text.RESET)
	}
}

// The same as the previous methods but in red. Used to draw attention to new comments which will either be downgraded to cyan or purple or removed.
func (cp *Compiler) CmR(comment string, tok *token.Token) {
	if settings.SHOW_COMPILER_COMMENTS && !(settings.IGNORE_BOILERPLATE && settings.ThingsToIgnore.Contains(tok.Source)) {
		println(text.RED + "// " + comment + text.RESET)
	}
}

// The compiler keeps its errors in the CommonParserBindle like eveerything else, and accesses them through
// its parser.

func (cp *Compiler) Throw(errorID string, tok *token.Token, args ...any) {
	cp.Cm("Throwing compiler error "+errorID, tok)
	cp.P.Throw(errorID, tok, args...)
}

func (cp *Compiler) ErrorsExist() bool {
	return len(cp.P.Common.Errors) > 0
}

func altType(t ...values.ValueType) AlternateType {
	return AltType(t...)
}

func (cp *Compiler) SetEnv(env *values.Map) {
	for _, child := range cp.Modules {
		child.SetEnv(env)
	}
	hubStore, _ := cp.GlobalVars.GetVar("$_env")
	cp.Vm.Mem[hubStore.MLoc].V = env
}
