import

golang "strconv"

newtype

Uint_32 = wrapper uint32

def

// A constructor.
Uint_32(i int) -> Uint_32 : golang {
    return uint32(i)
}

// Overloading "string".
string(z Uint_32) -> string : golang {
    return "Uint_32(" + strconv.Itoa(int(z.(uint32))) + ")"
}

// We implement functions on the Go side to determine equality and make a literal.
golang { 
    // Since in this example we're only implementing one wrapped type, the switch statements 
    // aren't really necessary, but they indicate what you would do if there was more than one.
    func Equals(x, y any) bool {
        switch x := x.(type) {
        case uint32:
            return x == y.(uint32)
        default:
            return false
        }
    }

    func Literal(x any) string {
        switch x := x.(type) {
        case uint32:
            return "Uint_32(" + strconv.Itoa(int(x)) + ")"
        default:
            return "can't serialize value"
        } 
    }
}